{"version":3,"file":"mathExpr.js","sourceRoot":"","sources":["../src/mathExpr.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as SearchMenu from \"@fluid-example/search-menu\";\nimport { IFluidObject } from \"@fluidframework/core-interfaces\";\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport * as Katex from \"katex\";\nimport { CharacterCodes } from \"./characterCodes\";\n\nexport const cursorTex = \" \\\\textcolor{#800080}{\\\\vert}\";\nexport const cursorColor = \"rgb(128, 0, 128)\";\nexport const boxEmptyParam = (viewText: string) => viewText.replace(/{}/g, \"{\\\\Box}\");\n\nexport enum MathTokenType {\n    Variable,\n    PatternVariable,\n    PatternType,\n    INT,\n    REAL,\n    Command,\n    LCurly,\n    RCurly,\n    MidCommand,\n    EndCommand,\n    Space,\n    Newline,\n    EOI,\n    SUB,\n    ADD,\n    DIV,\n    MUL,\n    LEQ,\n    GEQ,\n    OPAREN,\n    CPAREN,\n    COMMA,\n    IMPLIES,\n    Equals,\n}\n\nexport const Nope = -1;\n\nexport interface IMathCommand extends SearchMenu.ISearchMenuCommand {\n    arity?: number;\n    infix?: boolean;\n    sub?: boolean;\n    exp?: boolean;\n    op?: Operator;\n    prec?: TokenPrecedence;\n    texString?: string;\n    tokenType?: MathTokenType;\n}\n\nconst addCommand = (cmdTree: MergeTree.TST<IMathCommand>, command: IMathCommand) => {\n    if (command.texString) {\n        command.iconHTML = Katex.renderToString(command.texString, { throwOnError: false });\n    }\n    cmdTree.put(command.key, command);\n};\nexport const mathCmdTree = new MergeTree.TST<IMathCommand>();\n\nexport function mathMenuCreate(context: any, boundingElm: HTMLElement, onSubmit: (s: string, cmd?: IMathCommand) => void) {\n    return SearchMenu.searchBoxCreate(context, boundingElm, mathCmdTree, false, onSubmit);\n}\n\nconst greekLetters = [\n    \"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"constepsilon\",\n    \"zeta\", \"eta\", \"Gamma\", \"Delta\", \"Theta\", \"theta\", \"vartheta\",\n    \"iota\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"xi\", \"Lambda\", \"Xi\",\n    \"Pi\", \"pi\", \"varpi\", \"rho\", \"varrho\", \"sigma\", \"varsigma\",\n    \"Sigma\", \"Upsilon\", \"Phi\", \"upsilon\", \"phi\", \"varphi\", \"chi\",\n    \"psi\", \"omega\", \"Psi\", \"Omega\",\n];\nconst bigOpsSubExp = [\n    \"int\", \"sum\", \"prod\", \"coprod\", \"oint\",\n];\nconst bigOpsSub = [\n    \"bigcup\", \"bigcap\", \"bigsqcup\", \"bigvee\", \"bigwedge\", \"lim\",\n];\n\nexport enum TokenPrecedence {\n    NONE,\n    IMPLIES,\n    REL,\n    LOG,\n    IN,\n    ADD,\n    MUL,\n    NEG,\n    EXP,\n    UNDER,\n}\n\nexport interface ITokenProperties {\n    flags: TokenLexFlags;\n    op?: Operator;\n    precedence?: TokenPrecedence;\n    rightAssoc?: boolean;\n}\n\nexport enum TokenLexFlags {\n    None = 0x0,\n    PrimaryFirstSet = 0x1,\n    Binop = 0x2,\n    Relop = 0x4 | Binop,\n}\nconst singleTokText: string[] = [];\nsingleTokText[MathTokenType.SUB] = \"-\";\nsingleTokText[MathTokenType.DIV] = \"\";\nsingleTokText[MathTokenType.ADD] = \"+\";\nsingleTokText[MathTokenType.OPAREN] = \"(\";\nsingleTokText[MathTokenType.CPAREN] = \")\";\nsingleTokText[MathTokenType.COMMA] = \",\";\n\nexport function tokenText(tok: MathToken) {\n    if (tok.text !== undefined) {\n        return tok.text;\n    } else {\n        return singleTokText[tok.type];\n    }\n}\n\nenum Operator {\n    IMPLIES,\n    EQ,\n    LEQ,\n    GEQ,\n    MUL,\n    DIV,\n    ADD,\n    SUB,\n    EXP,\n    UNDER,\n    IN,\n    NOTIN,\n    SUBSET,\n    SETMINUS,\n    PLUSMINUS,\n    INTERSECTION,\n    AND,\n    OR,\n    UNION,\n    CONG,\n    SUBSETEQ,\n    VDASH,\n    EQUIV,\n    OWNS,\n    FORALL,\n    EXISTS,\n}\n\nconst texString: string[] = [];\ntexString[Operator.ADD] = \"+\";\ntexString[Operator.SUB] = \"-\";\ntexString[Operator.DIV] = \"\\\\frac\";\ntexString[Operator.EQ] = \"=\";\ntexString[Operator.UNDER] = \"_\";\ntexString[Operator.EXP] = \"^\";\ntexString[Operator.LEQ] = \"\\\\leq \";\ntexString[Operator.GEQ] = \"\\\\geq \";\ntexString[Operator.IMPLIES] = \"\\\\Rightarrow \";\ntexString[Operator.MUL] = \"\";\ntexString[Operator.IN] = \"\\\\in \";\ntexString[Operator.SETMINUS] = \"\\\\setminus \";\ntexString[Operator.PLUSMINUS] = \"\\\\pm \";\ntexString[Operator.INTERSECTION] = \"\\\\cap \";\ntexString[Operator.AND] = \"\\\\wedge \";\ntexString[Operator.OR] = \"\\\\vee \";\ntexString[Operator.UNION] = \"\\\\cup \";\ntexString[Operator.CONG] = \"\\\\cong \";\ntexString[Operator.SUBSETEQ] = \"\\\\subseteq \";\ntexString[Operator.VDASH] = \"\\\\vdash \";\ntexString[Operator.EQUIV] = \"\\\\equiv \";\ntexString[Operator.OWNS] = \"\\\\owns \";\ntexString[Operator.NOTIN] = \"\\\\notin \";\ntexString[Operator.SUBSET] = \"\\\\subset \";\n\nconst tokenProps: ITokenProperties[] = [];\ntokenProps[MathTokenType.INT] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.REAL] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.PatternVariable] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.Variable] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.Command] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.OPAREN] = { flags: TokenLexFlags.PrimaryFirstSet };\ntokenProps[MathTokenType.ADD] = {\n    flags: TokenLexFlags.Binop,\n    precedence: TokenPrecedence.ADD, op: Operator.ADD,\n};\ntokenProps[MathTokenType.SUB] = { flags: TokenLexFlags.Binop, precedence: TokenPrecedence.ADD, op: Operator.SUB };\ntokenProps[MathTokenType.DIV] = {\n    flags: TokenLexFlags.Binop,\n    precedence: TokenPrecedence.MUL, op: Operator.DIV,\n};\ntokenProps[MathTokenType.MUL] = { flags: TokenLexFlags.Binop, precedence: TokenPrecedence.MUL, op: Operator.MUL };\ntokenProps[MathTokenType.Equals] = { flags: TokenLexFlags.Relop, precedence: TokenPrecedence.REL, op: Operator.EQ };\ntokenProps[MathTokenType.LEQ] = { flags: TokenLexFlags.Relop, precedence: TokenPrecedence.REL, op: Operator.LEQ };\ntokenProps[MathTokenType.GEQ] = { flags: TokenLexFlags.Relop, precedence: TokenPrecedence.REL, op: Operator.GEQ };\ntokenProps[MathTokenType.IMPLIES] = { flags: TokenLexFlags.Binop, precedence: TokenPrecedence.IMPLIES, op: Operator.IMPLIES };\n\nconst operatorToPrecedence: TokenPrecedence[] = [];\noperatorToPrecedence[Operator.IMPLIES] = TokenPrecedence.IMPLIES;\noperatorToPrecedence[Operator.EQ] = TokenPrecedence.REL;\noperatorToPrecedence[Operator.LEQ] = TokenPrecedence.REL;\noperatorToPrecedence[Operator.GEQ] = TokenPrecedence.REL;\noperatorToPrecedence[Operator.IN] = TokenPrecedence.IN;\noperatorToPrecedence[Operator.MUL] = TokenPrecedence.MUL;\noperatorToPrecedence[Operator.DIV] = TokenPrecedence.MUL;\noperatorToPrecedence[Operator.ADD] = TokenPrecedence.ADD;\noperatorToPrecedence[Operator.SUB] = TokenPrecedence.ADD;\noperatorToPrecedence[Operator.UNDER] = TokenPrecedence.EXP;\noperatorToPrecedence[Operator.EXP] = TokenPrecedence.EXP;\noperatorToPrecedence[Operator.IN] = TokenPrecedence.IN;\noperatorToPrecedence[Operator.SETMINUS] = TokenPrecedence.ADD;\noperatorToPrecedence[Operator.PLUSMINUS] = TokenPrecedence.ADD;\noperatorToPrecedence[Operator.INTERSECTION] = TokenPrecedence.MUL;\noperatorToPrecedence[Operator.UNION] = TokenPrecedence.MUL;\noperatorToPrecedence[Operator.AND] = TokenPrecedence.LOG;\noperatorToPrecedence[Operator.OR] = TokenPrecedence.LOG;\noperatorToPrecedence[Operator.CONG] = TokenPrecedence.REL;\noperatorToPrecedence[Operator.SUBSETEQ] = TokenPrecedence.IN;\noperatorToPrecedence[Operator.SUBSET] = TokenPrecedence.IN;\noperatorToPrecedence[Operator.VDASH] = TokenPrecedence.IMPLIES;\noperatorToPrecedence[Operator.EQUIV] = TokenPrecedence.REL;\noperatorToPrecedence[Operator.OWNS] = TokenPrecedence.IN;\noperatorToPrecedence[Operator.NOTIN] = TokenPrecedence.IN;\n\n// SETMINUS, PLUSMINUS, INTERSECTION, AND, OR, UNION, CONG, SUBSETEQ, VDASH, EQUIV, OWNS\nconst binaryOperators = [\n    { key: \"setminus\", op: Operator.SETMINUS },\n    { key: \"times\", op: Operator.MUL },\n    { key: \"div\", op: Operator.DIV },\n    { key: \"pm\", op: Operator.PLUSMINUS },\n    { key: \"cap\", op: Operator.INTERSECTION },\n    { key: \"wedge\", op: Operator.AND },\n    { key: \"vee\", op: Operator.OR },\n    { key: \"land\", op: Operator.AND },\n    { key: \"cup\", op: Operator.UNION },\n];\nconst binaryRelations = [\n    { key: \"leq\", op: Operator.LEQ },\n    { key: \"geq\", op: Operator.GEQ },\n    { key: \"cong\", op: Operator.CONG },\n    { key: \"in\", op: Operator.IN },\n    { key: \"notin\", op: Operator.NOTIN },\n    { key: \"subset\", op: Operator.SUBSET },\n    { key: \"subseteq\", op: Operator.SUBSETEQ },\n    { key: \"vdash\", op: Operator.VDASH },\n    { key: \"equiv\", op: Operator.EQUIV },\n    { key: \"ni\", op: Operator.OWNS },\n    { key: \"owns\", op: Operator.OWNS },\n    { key: \"implies\", op: Operator.IMPLIES },\n];\n\nconst logic = [\n    { key: \"forall\", op: Operator.FORALL },\n    { key: \"exists\", op: Operator.EXISTS },\n];\n\ngreekLetters.map((letter) => addCommand(mathCmdTree,\n    { key: letter, arity: 0, texString: \"\\\\\" + letter + \" \", tokenType: MathTokenType.Variable }));\n\nbigOpsSubExp.map((name) => {\n    addCommand(mathCmdTree, {\n        key: name, arity: 0, sub: true, exp: true,\n        texString: \"\\\\\" + name + \" \",\n    });\n    addCommand(mathCmdTree, {\n        key: name + \"-over\", arity: 0, sub: true, exp: true,\n        texString: \"\\\\\" + name + \"_{}^{}\",\n    });\n});\n\nbigOpsSub.map((name) => addCommand(mathCmdTree, {\n    key: name, arity: 0, sub: true,\n    texString: \"\\\\\" + name + \" \",\n}));\n\nbinaryOperators.map((oper) => addCommand(mathCmdTree, {\n    key: oper.key, arity: 2, infix: true,\n    op: oper.op, texString: \"\\\\\" + oper.key + \" \",\n}));\n\nbinaryRelations.map((oper) => addCommand(mathCmdTree, {\n    key: oper.key, arity: 2, infix: true,\n    op: oper.op, texString: \"\\\\\" + oper.key + \" \",\n}));\n\nlogic.map((oper) => addCommand(mathCmdTree, {\n    key: oper.key, arity: 1,\n    op: oper.op, texString: \"\\\\\" + oper.key + \" \",\n}));\n\nconst superCmd = { key: \"^\", arity: 1 };\nconst subCmd = { key: \"_\", arity: 1 };\n\naddCommand(mathCmdTree, { key: \"cos\", arity: 0, exp: true, texString: \"\\\\cos \" });\naddCommand(mathCmdTree, { key: \"log\", arity: 0, exp: true, texString: \"\\\\log \" });\naddCommand(mathCmdTree, { key: \"ln\", arity: 0, exp: true, texString: \"\\\\ln \" });\naddCommand(mathCmdTree, { key: \"infty\", arity: 0, texString: \"\\\\infty \" });\naddCommand(mathCmdTree, { key: \"Box\", arity: 0, texString: \"\\\\Box \" });\naddCommand(mathCmdTree, { key: \"nabla\", arity: 0, texString: \"\\\\nabla \" });\n\naddCommand(mathCmdTree, { key: \"partial\", arity: 0, exp: true, texString: \"\\\\partial \" });\naddCommand(mathCmdTree, { key: \"neg\", arity: 0, texString: \"\\\\neg \" });\naddCommand(mathCmdTree, { key: \"overline\", arity: 1, texString: \"\\\\overline{} \" });\naddCommand(mathCmdTree, { key: \"circ\", arity: 0, texString: \"\\\\circ \" });\naddCommand(mathCmdTree, { key: \"sin\", arity: 0, exp: true, texString: \"\\\\sin \" });\naddCommand(mathCmdTree, { key: \"sqrt\", arity: 1, texString: \"\\\\sqrt{} \" });\naddCommand(mathCmdTree, { key: \"to\", arity: 0, texString: \"\\\\to \" });\naddCommand(mathCmdTree, { key: \"frac\", arity: 2, texString: \"\\\\frac{}{} \" });\n\nexport function printTokens(tokIndex: number, mathCursor: number, tokens: MathToken[], mathText: string) {\n    console.log(`Math indx ${tokIndex} cp ${mathCursor} is`);\n    let buf = \"\";\n    for (let i = 0, len = tokens.length; i < len; i++) {\n        const tok = tokens[i] as MathCommandToken;\n        buf += `${i} [${tok.start}, ${tok.end}): ${MathTokenType[tok.type]} ${mathText.substring(tok.start, tok.end)}`;\n        if (tok.endTok) {\n            buf += `et: ${tok.endTok.end}`;\n        }\n        buf += \"\\n\";\n    }\n    console.log(buf);\n}\n\nexport function posAtToken(tokIndex: number, tokens: MathToken[]) {\n    let pos = 0;\n    for (let i = 0; i < tokIndex; i++) {\n        if (i >= tokens.length) {\n            return pos;\n        }\n        const tok = tokens[i];\n        pos += (tok.end - tok.start);\n    }\n    return pos;\n}\n\nexport function tokenAtPos(mathCursor: number, tokens: MathToken[]) {\n    for (let i = 0; i < tokens.length; i++) {\n        if (tokens[i].start === mathCursor) {\n            return i;\n        }\n    }\n    return tokens.length;\n}\n\nexport function mathTokFwd(tokIndex: number, tokens: MathToken[]) {\n    const toklen = tokens.length;\n    let _tokIndex = tokIndex + 1;\n    while (_tokIndex < toklen) {\n        if ((tokens[_tokIndex].type === MathTokenType.Space) ||\n            ((tokens[_tokIndex].type === MathTokenType.Command) &&\n                ((tokens[_tokIndex] as MathCommandToken).isModifier))) {\n            _tokIndex++;\n        } else {\n            break;\n        }\n    }\n    return _tokIndex;\n}\n\nexport interface IMathCursor {\n    mathCursor: number;\n    mathTokenIndex: number;\n}\n\nexport interface IMathMarker extends MergeTree.Marker {\n    mathTokens: MathToken[];\n    mathText: string;\n    mathInstance?: IFluidObject;\n}\n\n/**\n * This function updates the mathCursor and mathTokenIndex properties of mathMarker\n * @param mathMarker marker for end of math region\n */\nexport function bksp(mathMarker: IMathMarker, mc: IMathCursor) {\n    let prevTokIndex = mathTokRev(mc.mathTokenIndex, mathMarker.mathTokens);\n    while ((prevTokIndex >= 0) &&\n        ((mathMarker.mathTokens[prevTokIndex].type === MathTokenType.EndCommand) ||\n            (mathMarker.mathTokens[prevTokIndex].type === MathTokenType.MidCommand))) {\n        prevTokIndex--;\n    }\n    if (prevTokIndex >= 0) {\n        const prevTok = mathMarker.mathTokens[prevTokIndex];\n        mc.mathTokenIndex = prevTokIndex;\n        mc.mathCursor = prevTok.start;\n        if ((prevTok.type === MathTokenType.Command) &&\n            (prevTok.cmdInfo.arity > 0)) {\n            const prevCommandTok = prevTok as MathCommandToken;\n            return { start: prevTok.start, end: prevCommandTok.endTok.end };\n        } else if ((prevTok.isSymbol) && (hasSymbolModifiers(prevTok as MathSymbolToken))) {\n            return { start: prevTok.start, end: furthestModifierEnd(prevTok as MathSymbolToken) };\n        } else {\n            return { start: prevTok.start, end: prevTok.end };\n        }\n    }\n}\n\nexport function mathTokRev(tokIndex: number, tokens: MathToken[]) {\n    let _tokIndex = tokIndex - 1;\n    if (_tokIndex > (tokens.length - 1)) {\n        _tokIndex = tokens.length - 1;\n    }\n    while (_tokIndex >= 0) {\n        const tok = tokens[_tokIndex];\n        if ((tok.type === MathTokenType.Space) ||\n            ((tok.type === MathTokenType.Command) &&\n                ((tok as MathCommandToken).isModifier))) {\n            _tokIndex--;\n        } else {\n            break;\n        }\n    }\n    if (_tokIndex >= 0) {\n        return _tokIndex;\n    } else {\n        return Nope;\n    }\n}\n\nexport class MathToken {\n    // command for which this token ends an operand\n    public paramCmd?: MathToken;\n    // operand index if paramCmd defined\n    public paramIndex?: number;\n    public isSymbol?: boolean;\n    public text?: string;\n\n    constructor(public type: MathTokenType, public start: number, public end: number,\n        public cmdInfo?: IMathCommand) {\n    }\n}\n\nexport class MathSymbolToken extends MathToken {\n    public subCmd?: MathCommandToken;\n    public superCmd?: MathCommandToken;\n    public isSymbol = true;\n    public isModifier?: boolean;\n\n    constructor(type: MathTokenType, start: number, end: number,\n        public cmdInfo?: IMathCommand) {\n        super(type, start, end, cmdInfo);\n    }\n}\n\nfunction hasSymbolModifiers(symTok: MathSymbolToken) {\n    return symTok.subCmd || symTok.superCmd;\n}\n\nfunction furthestModifierEnd(symTok: MathSymbolToken) {\n    if (symTok.subCmd) {\n        if (symTok.superCmd) {\n            return Math.max(symTok.subCmd.endTok.end, symTok.superCmd.endTok.end);\n        } else {\n            return symTok.subCmd.endTok.end;\n        }\n    } else {\n        return symTok.superCmd.endTok.end;\n    }\n}\n\nexport class MathCommandToken extends MathSymbolToken {\n    // the number of operands seen so far\n    public paramRefRemaining?: number;\n    // the token ending the last operand\n    public endTok?: MathToken;\n    // the tokens starting each parameter\n    public paramStarts: MathToken[];\n    public symbolModified?: MathSymbolToken;\n\n    constructor(type: MathTokenType, start: number, end: number,\n        public cmdInfo?: IMathCommand) {\n        super(type, start, end, cmdInfo);\n    }\n}\n\nfunction isAlpha(c: number) {\n    return ((c >= CharacterCodes.a) && (c <= CharacterCodes.z)) ||\n        ((c >= CharacterCodes.A) && (c <= CharacterCodes.Z));\n}\n\nfunction isNumber(c: number) {\n    return ((c >= CharacterCodes._0) && (c <= CharacterCodes._9));\n}\n\nfunction isMathPunct(c: number) {\n    return (c === CharacterCodes.openParen) ||\n        (c === CharacterCodes.closeParen) ||\n        (c === CharacterCodes.equals) ||\n        (c === CharacterCodes.minus) ||\n        (c === CharacterCodes.plus);\n}\n\nexport function transformInputCode(c: number) {\n    if (isAlpha(c) || isMathPunct(c) || isNumber(c)) {\n        return String.fromCharCode(c);\n    } else {\n        switch (c) {\n            case CharacterCodes.caret:\n                return \"^{}\";\n            case CharacterCodes._:\n                return \"_{}\";\n            case CharacterCodes.cr:\n                // AF: restrict to top-level (pass into this function whether top-level)\n                return \"\\n\";\n            default:\n        }\n    }\n}\n\ninterface ICharStream {\n    chars: string;\n    index: number;\n}\n\nconst eoc = Nope;\n\nfunction charStreamPeek(charStream: ICharStream) {\n    return charStreamGet(charStream, false);\n}\n\nfunction charStreamAdvance(charStream: ICharStream, amt = 1) {\n    charStream.index += amt;\n    if (charStream.index > charStream.chars.length) {\n        charStream.index = charStream.chars.length;\n    }\n}\n\nfunction charStreamRetreat(charStream: ICharStream, amt: number) {\n    charStream.index -= amt;\n\n    if (charStream.index < 0) {\n        charStream.index = 0;\n    }\n}\n\nfunction charStreamGet(charStream: ICharStream, advance = true) {\n    const charsLen = charStream.chars.length;\n    if (charStream.index < charsLen) {\n        const ch = charStream.chars.charCodeAt(charStream.index);\n        if (advance) {\n            charStream.index++;\n        }\n        return ch;\n    } else {\n        return eoc;\n    }\n}\n\nfunction charStreamSubstring(start: number, charStream: ICharStream) {\n    return charStream.chars.substring(start, charStream.index);\n}\n\nfunction isDecimalDigit(c: number): boolean {\n    return c >= CharacterCodes._0 && c <= CharacterCodes._9;\n}\n\nfunction isVariableChar(c: number): boolean {\n    return (c >= CharacterCodes.a && c <= CharacterCodes.z) ||\n        (c >= CharacterCodes.A && c <= CharacterCodes.Z);\n}\n\n// assumes char stream points at first character in identifier\nfunction lexId(charStream: ICharStream): string {\n    const startOffset = charStream.index;\n    let ch: number;\n    do {\n        ch = charStreamGet(charStream);\n    } while (isVariableChar(ch));\n    if (ch !== eoc) {\n        charStreamRetreat(charStream, 1);\n    }\n    return charStreamSubstring(startOffset, charStream);\n}\n\nfunction lexCommand(tokens: MathToken[], charStream: ICharStream, cmdStack: MathToken[]) {\n    const startPos = charStream.index;\n    charStreamAdvance(charStream); // skip the backslash\n    const key = lexId(charStream);\n    let tokenType = MathTokenType.Command;\n    const cmd = mathCmdTree.get(key);\n    if (cmd.tokenType !== undefined) {\n        tokenType = cmd.tokenType;\n    }\n    if (cmd.arity > 0) {\n        // consume the \"{\"\n        charStreamAdvance(charStream);\n    }\n    const tok = new MathCommandToken(tokenType, startPos, charStream.index, cmd);\n    tokens.push(tok);\n    if (cmd.arity > 0) {\n        tok.paramRefRemaining = cmd.arity;\n        cmdStack.push(tok);\n    }\n    return tok;\n}\n\nexport function lexSpace(tokens: MathToken[], charStream: ICharStream) {\n    const startPos = charStream.index;\n    let c = charStreamPeek(charStream);\n    while (c === CharacterCodes.space) {\n        charStreamAdvance(charStream);\n        c = charStreamPeek(charStream);\n    }\n    if (startPos < charStream.index) {\n        tokens.push(new MathToken(MathTokenType.Space, startPos, charStream.index));\n    }\n}\n\n// chars not recognized as math input (such as \"!\") stopped\n// at input filter level and not expected\nfunction lexCharStream(charStream: ICharStream, tokens: MathToken[],\n    cmdStack: MathCommandToken[]) {\n    let prevSymTok: MathSymbolToken;\n\n    function modSymTok(curTok: MathCommandToken, isSub = true) {\n        if (prevSymTok) {\n            let symTok = prevSymTok;\n            if (prevSymTok.isModifier) {\n                symTok = (symTok as MathCommandToken).symbolModified;\n            }\n            if (isSub) {\n                symTok.subCmd = curTok;\n            } else {\n                symTok.superCmd = curTok;\n            }\n            curTok.symbolModified = symTok;\n        }\n    }\n\n    function lexEq(): MathToken {\n        const pos = charStream.index;\n        // first character is '='\n        charStreamAdvance(charStream);\n        const nextChar = charStreamPeek(charStream);\n        if (nextChar === CharacterCodes.greaterThan) {\n            // recognized an '=>'\n            charStreamAdvance(charStream);\n            return new MathToken(MathTokenType.IMPLIES, pos, pos + 2);\n        } else {\n            // recognized \"=\"\n            return new MathToken(MathTokenType.Equals, pos, pos + 1);\n        }\n    }\n\n    // reals also\n    function lexNumber(): MathToken {\n        const start = charStream.index;\n        let ch: number;\n        do {\n            ch = charStreamGet(charStream);\n        } while (isDecimalDigit(ch));\n        if (ch !== eoc) {\n            charStreamRetreat(charStream, 1);\n        }\n        const numString = charStreamSubstring(start, charStream);\n        const tok = new MathToken(MathTokenType.INT, start, charStream.index);\n        tok.text = numString;\n        return tok;\n    }\n\n    let c = charStreamPeek(charStream);\n    while (c !== eoc) {\n        // single character variables (unless preceded by '?')\n        if (isVariableChar(c)) {\n            const start = charStream.index;\n            charStreamAdvance(charStream);\n            const vartok = new MathSymbolToken(MathTokenType.Variable,\n                start, charStream.index);\n            prevSymTok = vartok;\n            vartok.text = charStreamSubstring(start, charStream);\n            if (charStreamPeek(charStream) === CharacterCodes.colon) {\n                // it's a pattern variable!\n                vartok.type = MathTokenType.PatternVariable;\n            }\n            tokens.push(vartok);\n        } else if (isDecimalDigit(c)) {\n            tokens.push(lexNumber());\n        } else {\n            switch (c) {\n                case CharacterCodes.backslash:\n                    const cmdTok = lexCommand(tokens, charStream, cmdStack);\n                    if ((cmdTok.type === MathTokenType.Variable) ||\n                        (cmdTok.cmdInfo && (cmdTok.cmdInfo.arity === 0))) {\n                        prevSymTok = cmdTok;\n                    }\n                    break;\n                case CharacterCodes.equals:\n                    tokens.push(lexEq());\n                    break;\n                case CharacterCodes.slash:\n                    tokens.push(new MathToken(MathTokenType.DIV, charStream.index, charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.plus:\n                    tokens.push(new MathToken(MathTokenType.ADD, charStream.index, charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.comma:\n                    tokens.push(new MathToken(MathTokenType.COMMA, charStream.index, charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.minus:\n                    tokens.push(new MathToken(MathTokenType.SUB, charStream.index, charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.caret: {\n                    const pos = charStream.index;\n                    const tok = new MathCommandToken(MathTokenType.Command, pos, pos + 2, superCmd);\n                    tok.paramRefRemaining = 1;\n                    tok.isModifier = true;\n                    cmdStack.push(tok);\n                    modSymTok(tok, false);\n                    tokens.push(tok);\n                    charStreamAdvance(charStream, 2);\n                    break;\n                }\n                case CharacterCodes._: {\n                    const pos = charStream.index;\n                    const tok = new MathCommandToken(MathTokenType.Command, pos, pos + 2, subCmd);\n                    tok.paramRefRemaining = 1;\n                    tok.isModifier = true;\n                    cmdStack.push(tok);\n                    modSymTok(tok);\n                    tokens.push(tok);\n                    charStreamAdvance(charStream, 2);\n                    break;\n                }\n                case CharacterCodes.openBrace:\n                    console.log(`shouldn't see { at pos ${charStream.index})`);\n                    printTokens(0, 0, tokens, charStream.chars);\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.closeBrace: {\n                    const start = charStream.index;\n                    let tokenType = MathTokenType.RCurly;\n                    let cmd: MathCommandToken;\n                    if (cmdStack.length > 0) {\n                        cmd = cmdStack[cmdStack.length - 1];\n                        if (cmd.paramRefRemaining > 1) {\n                            charStreamAdvance(charStream); // consume the following \"{\"\n                            tokenType = MathTokenType.MidCommand;\n                        }\n                    }\n                    charStreamAdvance(charStream);\n                    const tok = new MathToken(tokenType, start, charStream.index);\n                    tokens.push(tok);\n                    if (cmd !== undefined) {\n                        tok.paramCmd = cmd;\n                        tok.paramIndex = cmd.cmdInfo.arity - cmd.paramRefRemaining;\n                        cmd.paramRefRemaining--;\n                        if (cmd.paramRefRemaining === 0) {\n                            cmdStack.pop();\n                            tok.type = MathTokenType.EndCommand;\n                            cmd.endTok = tok;\n                        }\n                    }\n                    break;\n                }\n                case CharacterCodes.openParen:\n                    tokens.push(new MathToken(MathTokenType.OPAREN, charStream.index,\n                        charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.closeParen:\n                    tokens.push(new MathToken(MathTokenType.CPAREN, charStream.index,\n                        charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case CharacterCodes.space:\n                    lexSpace(tokens, charStream);\n                    break;\n                case CharacterCodes.linefeed:\n                    tokens.push(new MathToken(MathTokenType.Newline, charStream.index,\n                        charStream.index + 1));\n                    charStreamAdvance(charStream);\n                    break;\n                case eoc:\n                    break;\n                case CharacterCodes.question: {\n                    charStreamAdvance(charStream);\n                    const start = charStream.index;\n                    const vartext = lexId(charStream);\n                    const vartok = new MathToken(MathTokenType.PatternVariable,\n                        start, charStream.index);\n                    vartok.text = vartext;\n                    tokens.push(vartok);\n                    break;\n                }\n                case CharacterCodes.colon: {\n                    charStreamAdvance(charStream);\n                    const start = charStream.index;\n                    const varTypeText = lexId(charStream);\n                    const vartok = new MathToken(MathTokenType.PatternType,\n                        start, charStream.index);\n                    vartok.text = varTypeText;\n                    tokens.push(vartok);\n                    break;\n                }\n                default:\n                    const ch = charStream.chars.charAt(charStream.index);\n                    console.log(`shouldn't see ${ch} at pos ${charStream.index})`);\n                    printTokens(0, 0, tokens, charStream.chars);\n                    charStreamAdvance(charStream);\n            }\n        }\n        c = charStreamPeek(charStream);\n    }\n    return tokens;\n}\n\nexport function lexMath(mathBuffer: string) {\n    return lexCharStream({ chars: mathBuffer, index: 0 }, [] as MathToken[], [] as MathCommandToken[]);\n}\n\ninterface ITokenStream {\n    text: string;\n    tokens: MathToken[];\n    index: number;\n    end: number;\n}\n\nfunction tokStreamPeek(tokStream: ITokenStream) {\n    return tokStreamGet(tokStream, false);\n}\n\nexport function tokStreamAtEOI(tokStream: ITokenStream) {\n    let tokenEndIndex = tokStream.tokens.length;\n    if (tokStream.end >= 0) {\n        tokenEndIndex = tokStream.end;\n    }\n    return (tokenEndIndex === tokStream.index);\n}\n\nfunction tokStreamAdvance(tokStream: ITokenStream) {\n    tokStreamGet(tokStream, true);\n}\n\nfunction tokStreamGet(tokStream: ITokenStream, advance = true): MathToken {\n    let tokenEndIndex = tokStream.tokens.length;\n    if (tokStream.end >= 0) {\n        tokenEndIndex = tokStream.end;\n    }\n    if (tokStream.index < tokenEndIndex) {\n        const tok = tokStream.tokens[tokStream.index];\n        if (advance) {\n            tokStream.index++;\n        }\n        return tok;\n    } else {\n        return { end: Nope, start: Nope, type: MathTokenType.EOI };\n    }\n}\n\nfunction tokStreamCreateFromRange(text: string, tokens: MathToken[], start: number, end: number) {\n    return { text, tokens, index: start, end };\n}\n\nfunction tokStreamCreate(text: string, tokens: MathToken[], filter = true) {\n    let _tokens = tokens;\n    if (filter) {\n        _tokens = _tokens.filter((v) => v.type !== MathTokenType.Space);\n    }\n    return tokStreamCreateFromRange(text, _tokens, 0, Nope);\n}\n\nexport enum ExprType {\n    INTEGER,\n    RATIONAL,\n    REAL,\n    VARIABLE,\n    PATTERNVAR,\n    BINOP,\n    UNOP,\n    TUPLE,\n    CALL,\n    ERROR,\n}\nnamespace Constants {\n    export function matchConstant(c: IConstant, e: IExpr) {\n        if (isConstant(e)) {\n            const prom = promote(c, e as IConstant);\n            if (prom.c1.type === ExprType.RATIONAL) {\n                const r1 = prom.c1 as IRational;\n                const r2 = prom.c2 as IRational;\n                return (r1.a === r2.a) && (r1.b === r2.b);\n            } else {\n                return (prom.c1 as IReal).value === (prom.c2 as IReal).value;\n            }\n        }\n        return false;\n    }\n\n    export function makeInt(n: number): IReal {\n        return { type: ExprType.INTEGER, value: n };\n    }\n\n    export function rationalOp(op: Operator, r1: IRational, r2: IRational) {\n        const l = lcd(r1, r2);\n        const _r1 = l.r1;\n        const _r2 = l.r2;\n        switch (op) {\n            case Operator.ADD:\n                return { type: ExprType.RATIONAL, a: _r1.a + _r2.a, b: _r1.b };\n            case Operator.SUB:\n                return { type: ExprType.RATIONAL, a: _r1.a - _r2.a, b: _r1.b };\n            case Operator.MUL:\n                return simplifyRational({ type: ExprType.RATIONAL, a: _r1.a * _r2.a, b: _r1.b * _r1.b });\n            case Operator.DIV:\n                return simplifyRational({ type: ExprType.RATIONAL, a: _r1.a * _r2.b, b: _r1.b * _r2.a });\n            case Operator.EXP:\n                if (_r2.b === 1) {\n                    return simplifyRational({ type: ExprType.RATIONAL, a: Math.pow(_r1.a, _r2.a), b: Math.pow(_r1.b, _r2.a) });\n                } else if ((_r2.a % _r2.b) === 0) {\n                    const exp = _r2.a / _r2.b;\n                    return simplifyRational({ type: ExprType.RATIONAL, a: Math.pow(_r1.a, exp), b: Math.pow(_r1.b, exp) });\n                } else {\n                    // punt to real\n                    return ({ type: ExprType.REAL, value: Math.pow(_r1.a / _r1.b, _r2.a / _r2.b) });\n                }\n            default:\n        }\n    }\n\n    export function negate(c: IConstant): IConstant {\n        if (c.type === ExprType.RATIONAL) {\n            const r = c as IRational;\n            const rat: IRational = { type: ExprType.RATIONAL, a: -r.a, b: r.b };\n            return rat;\n        } else {\n            const real = c as IReal;\n            return { type: c.type, value: -real.value };\n        }\n    }\n\n    export function isNegative(c: IConstant): boolean {\n        if (c.type === ExprType.RATIONAL) {\n            const r = c as IRational;\n            return ((r.a < 0) && (r.b > 0)) || ((r.a > 0) && (r.b < 0));\n        } else {\n            const real = c as IReal;\n            return real.value < 0;\n        }\n    }\n\n    // update to handle negative integers and rationals\n    function gcd(a: number, b: number): number {\n        if (b === 0) {\n            return a;\n        } else if (a === 0) {\n            return b;\n        } else {\n            return gcd(b, a % b);\n        }\n    }\n\n    function lcm(k1: number, k2: number) {\n        return (Math.abs(k1 * k2) / gcd(k1, k2));\n    }\n\n    export function lcd(r1: IRational, r2: IRational) {\n        if (r2.b === r1.b) {\n            return { r1, r2 };\n        } else {\n            const d = lcm(r1.b, r2.b);\n            let f = d / r1.b;\n            let nr1: IRational;\n            if (r1.a === 0) {\n                nr1 = { type: ExprType.RATIONAL, a: 0, b: d };\n            } else {\n                nr1 = { type: ExprType.RATIONAL, a: f * r1.a, b: f * r1.b };\n            }\n            f = d / r2.b;\n            let nr2: IRational;\n            if (r2.a === 0) {\n                nr2 = { type: ExprType.RATIONAL, a: 0, b: d };\n            } else {\n                nr2 = { type: ExprType.RATIONAL, a: f * r2.a, b: f * r2.b };\n            }\n            return { r1: nr1, r2: nr2 };\n        }\n    }\n\n    export function simplifyRational(rat: IRational): IExpr {\n        if ((rat.a % rat.b) === 0) {\n            return { type: ExprType.INTEGER, value: rat.a / rat.b };\n        }\n        const d = gcd(rat.a, rat.b);\n        if (d === 1) {\n            return rat;\n        } else {\n            const resrat: IRational = { type: ExprType.RATIONAL, a: rat.a / d, b: rat.b / d };\n            return resrat;\n        }\n    }\n\n    export function convertConstant(c: IConstant, type: ExprType): IConstant {\n        if (c.type < type) {\n            if (c.type === ExprType.INTEGER) {\n                if (type === ExprType.REAL) {\n                    return { type: ExprType.REAL, value: (c as IReal).value };\n                } else {\n                    // type == ExprType.RATIONAL\n                    const rat: IRational = { type: ExprType.RATIONAL, a: (c as IReal).value, b: 1 };\n                    return rat;\n                }\n            } else if (c.type === ExprType.RATIONAL) {\n                // type == ExprType.REAL\n                const rat = c as IRational;\n                return { type: ExprType.REAL, value: rat.a / rat.b };\n            }\n        } else {\n            return c;\n        }\n    }\n\n    export function promote(a: IConstant, b: IConstant) {\n        if (a.type === b.type) {\n            return { c1: a, c2: b };\n        } else if (a.type < b.type) {\n            return { c1: convertConstant(a, b.type), c2: b };\n        } else {\n            return { c1: a, c2: convertConstant(b, a.type) };\n        }\n    }\n}\n\nfunction exprToTexParens(expr: IExpr) {\n    return exprToTex(expr, true, TokenPrecedence.NONE, false, true);\n}\n\nfunction isInfix(op: Operator) {\n    return (op !== Operator.DIV);\n}\n\nfunction isParamOp(op: Operator) {\n    return (op === Operator.EXP) || (op === Operator.UNDER);\n}\n\nfunction exprToTex(expr: IExpr, inputMode = true, prevPrecedence = TokenPrecedence.NONE, left = false, alwaysParens = false): string {\n    let tex = expr.pendingParens ? expr.pendingParens : \"\";\n    const showParens = alwaysParens || (inputMode && (expr.parenthesized));\n    let op1Tex: string;\n    let op2Tex: string;\n    switch (expr.type) {\n        case ExprType.TUPLE: {\n            const tuple = expr as ITuple;\n            if (!expr.pendingParens) {\n                tex += \"(\";\n            }\n            for (let i = 0, len = tuple.elements.length; i < len; i++) {\n                if (i > 0) {\n                    tex += \",\";\n                }\n                tex += exprToTex(tuple.elements[i], inputMode, TokenPrecedence.MUL,\n                    false, alwaysParens);\n            }\n            if (!expr.pendingParens) {\n                tex += \")\";\n            }\n            break;\n        }\n        case ExprType.BINOP:\n            const binex = expr as IBinop;\n            const precedence = operatorToPrecedence[binex.op];\n            if (isInfix(binex.op)) {\n                const paramOp = isParamOp(binex.op);\n                op1Tex = exprToTex(binex.operand1, inputMode, precedence, true, alwaysParens);\n                let rightPrec = precedence;\n                if (paramOp) {\n                    rightPrec = TokenPrecedence.NONE;\n                }\n                op2Tex = exprToTex(binex.operand2, inputMode, rightPrec, false, alwaysParens);\n                let parenthesize = showParens;\n                if (!parenthesize) {\n                    if (left) {\n                        parenthesize = (precedence < prevPrecedence) && (!expr.pendingParens);\n                    } else {\n                        parenthesize = (precedence <= prevPrecedence) && (!expr.pendingParens);\n                    }\n                }\n                if (parenthesize) {\n                    tex += \"(\";\n                }\n                tex += op1Tex;\n                tex += texString[binex.op];\n                if (paramOp) {\n                    tex += \"{\";\n                }\n                tex += op2Tex;\n                if (paramOp) {\n                    tex += \"}\";\n                }\n                if (parenthesize) {\n                    tex += \")\";\n                }\n            } else {\n                const paramPrec = inputMode ? precedence : TokenPrecedence.NONE;\n                op1Tex = exprToTex(binex.operand1, inputMode, paramPrec, false, alwaysParens);\n                op2Tex = exprToTex(binex.operand2, inputMode, paramPrec, false, alwaysParens);\n                tex += texString[binex.op];\n                tex += \"{\" + op1Tex + \"}\";\n                tex += \"{\" + op2Tex + \"}\";\n            }\n            break;\n        case ExprType.UNOP:\n            const unex = expr as IUnop;\n            tex += \"-\" + exprToTex(unex.operand1, inputMode, TokenPrecedence.NEG, false, alwaysParens);\n            break;\n        case ExprType.RATIONAL: {\n            const rat = expr as IRational;\n            if (Constants.isNegative(rat)) {\n                tex += \"-\";\n            }\n            tex += \"\\\\frac{\" + Math.abs(rat.a).toString() + \"}{\" + Math.abs(rat.b).toString() + \"}\";\n            break;\n        }\n        case ExprType.CALL: {\n            const ecall = expr as ICall;\n            if ((!ecall.notFound) && (!ecall.prefixCmds)) {\n                tex += \"\\\\\" + ecall.name;\n                if (ecall.sub) {\n                    tex += \"_{\" + exprToTex(ecall.sub, inputMode) + \"}\";\n                }\n                if (ecall.exp) {\n                    tex += \"^{\" + exprToTex(ecall.exp, inputMode) + \"}\";\n                }\n                tex += \" \";\n                if (ecall.params.length === 1) {\n                    if (ecall.curlies) {\n                        tex += \"{\";\n                    }\n                    tex += exprToTex(ecall.params[0], inputMode);\n                    if (ecall.curlies) {\n                        tex += \"}\";\n                    }\n                }\n            } else if (ecall.notFound) {\n                tex += \"\\\\class{err}{\\\\mathrm{\\\\backslash \" + ecall.name + \"}}\";\n            } else {\n                tex += \"\\\\mathrm{\\\\backslash \" + ecall.name + \"}\";\n            }\n            break;\n        }\n        case ExprType.INTEGER:\n        case ExprType.REAL: {\n            const c = expr as IConstant;\n            if (c.assignedVar) {\n                tex += exprToTex(c.assignedVar, inputMode, prevPrecedence, left, alwaysParens);\n            } else {\n                tex += (expr as IReal).value;\n            }\n            break;\n        }\n        case ExprType.VARIABLE: {\n            const vexpr = expr as IVariable;\n            tex += vexpr.text;\n            if (vexpr.sub) {\n                tex += \"_{\" + exprToTex(vexpr.sub, inputMode, TokenPrecedence.NONE, false, alwaysParens) + \"}\";\n            }\n            break;\n        }\n        case ExprType.PATTERNVAR:\n            const pvar = expr as IPatternVar;\n            if (pvar.text === \"cur\") {\n                tex += \"\\\\cssId{mcur}{\\\\cdots}\";\n            } else {\n                tex += \"?\" + pvar.text + ((pvar.pvarType === PatternVarType.Any) ? \"\" : (\":\" + PatternVarType[pvar.pvarType]));\n            }\n            break;\n        default:\n    }\n    return tex;\n}\n\n// for now, object will be fast enough\ninterface IEnvironment {\n    [s: string]: IExpr;\n}\n\nfunction emptyEnvironment() {\n    const env: IEnvironment = {};\n    return env;\n}\n\nfunction bind(env: IEnvironment, pvarName: string, type: PatternVarType, e: IExpr): boolean {\n    if ((type === PatternVarType.Const) && (!isConstant(e))) {\n        return false;\n    } else if ((type === PatternVarType.Var) && (e.type !== ExprType.VARIABLE)) {\n        return false;\n    } else if ((type === PatternVarType.Expr) && (isConstant(e))) {\n        return false;\n    }\n    let existing: IExpr;\n    if (env) {\n        existing = env[pvarName];\n    }\n    if (existing) {\n        return match(existing, e, env, true);\n    } else {\n        env[pvarName] = e;\n        return true;\n    }\n}\n\nfunction matchS(p: string, expr: IExpr, env?: IEnvironment): boolean {\n    const pattern = parse(p);\n    return match(pattern, expr, env);\n}\n\nfunction parse(s: string): IExpr {\n    const tokens = lexCharStream({ chars: s, index: 0 }, [], []);\n    const parserContext: IParserContext = {};\n    return parseExpr(tokStreamCreate(s, tokens), parserContext);\n}\n\nconst diagMatch = false;\nfunction match(pattern: IExpr, expr: IExpr, env?: IEnvironment, literal = false): boolean {\n    if (diagMatch) {\n        const texP = exprToTex(pattern);\n        const texE = exprToTexParens(expr);\n        console.log(`matching ${texP} vs ${texE}`);\n    }\n    let matched = false;\n    if (isConstant(pattern)) {\n        matched = Constants.matchConstant(pattern, expr);\n        if ((!matched) && diagMatch) {\n            console.log(\"constant match failed\");\n        }\n        return matched;\n    }\n    switch (pattern.type) {\n        case ExprType.PATTERNVAR: {\n            const pvar = pattern as IPatternVar;\n            matched = bind(env, pvar.text, pvar.pvarType, expr);\n            if ((!matched) && diagMatch) {\n                console.log(\"bind failed\");\n            }\n            return matched;\n        }\n        case ExprType.VARIABLE: {\n            if (literal) {\n                if (expr.type !== ExprType.VARIABLE) {\n                    if (diagMatch) {\n                        console.log(`literal variable match failed with expr type ${ExprType[expr.type]}`);\n                    }\n                    return false;\n                } else {\n                    const vpat = pattern as IVariable;\n                    const vexpr = expr as IVariable;\n                    matched = (vpat.text === vexpr.text);\n                    if ((!matched) && diagMatch) {\n                        console.log(\"literal variable match failed (2)\");\n                    }\n                    if (matched && vpat.sub) {\n                        if (vexpr.sub) {\n                            // only literal match of subscript expressions for now\n                            matched = match(vpat.sub, vexpr.sub, env, true);\n                        } else {\n                            matched = false;\n                        }\n                    }\n                    return matched;\n                }\n            } else {\n                matched = bind(env, (pattern as IVariable).text, PatternVarType.Any, expr);\n                if ((!matched) && diagMatch) {\n                    console.log(\"bind failed\");\n                }\n                return matched;\n            }\n        }\n        case ExprType.UNOP: {\n            const punex = pattern as IUnop;\n            if (expr.type === ExprType.UNOP) {\n                const eunex = expr as IUnop;\n                if (punex.op !== eunex.op) {\n                    if (diagMatch) {\n                        console.log(\"unop match failed\");\n                    }\n                    return false;\n                } else {\n                    return match(punex.operand1, eunex.operand1, env, literal);\n                }\n            } else if (isConstant(expr)) {\n                if (Constants.isNegative(expr)) {\n                    const n = Constants.negate(expr);\n                    return match(punex.operand1, n, env, literal);\n                }\n            }\n            break;\n        }\n        case ExprType.BINOP: {\n            if (expr.type === ExprType.BINOP) {\n                const pbinex = pattern as IBinop;\n                const ebinex = expr as IBinop;\n                if (pbinex.op !== ebinex.op) {\n                    if (diagMatch) {\n                        console.log(\"binop match failed\");\n                    }\n                    return false;\n                } else {\n                    return match(pbinex.operand1, ebinex.operand1, env) &&\n                        match(pbinex.operand2, ebinex.operand2, env);\n                }\n            }\n            break;\n        }\n        default:\n    }\n    if (diagMatch) {\n        console.log(`type mismatch ${ExprType[pattern.type]} vs ${ExprType[expr.type]}`);\n    }\n    return false;\n}\n\nfunction isConstant(expr: IExpr) {\n    return (expr.type === ExprType.INTEGER) || (expr.type === ExprType.RATIONAL) ||\n        (expr.type === ExprType.REAL);\n}\n\nfunction applyBinop(binex: IBinop): IExpr {\n    const promoted = Constants.promote(binex.operand1, binex.operand2);\n    const c1 = promoted.c1;\n    const c2 = promoted.c2;\n\n    if ((c1.type === ExprType.INTEGER) || (c1.type === ExprType.REAL)) {\n        const rc1 = (c1 as IReal).value;\n        const rc2 = (c2 as IReal).value;\n\n        switch (binex.op) {\n            case Operator.ADD:\n                return { type: c1.type, value: rc1 + rc2 };\n            case Operator.SUB:\n                return { type: c1.type, value: rc1 - rc2 };\n            case Operator.MUL:\n                return { type: c1.type, value: rc1 * rc2 };\n            case Operator.DIV:\n                if (c1.type === ExprType.INTEGER) {\n                    return Constants.simplifyRational({ type: ExprType.RATIONAL, a: rc1, b: rc2 });\n                } else {\n                    return { type: c1.type, value: rc1 / rc2 };\n                }\n            case Operator.EXP:\n                return { type: c1.type, value: Math.pow(rc1, rc2) };\n            default:\n                return (binex);\n        }\n    } else {\n        // rational\n        return Constants.rationalOp(binex.op, c1 as IRational, c2 as IRational);\n    }\n}\n\nexport function extractFirstVar(s: string) {\n    const expr = parse(s);\n    let v: IVariable;\n    walk(expr, (e) => {\n        if (e.type === ExprType.VARIABLE) {\n            if (!v) {\n                v = e as IVariable;\n            }\n        }\n        return true;\n    });\n    return v;\n}\n\n// assume left and right sides linear in v\n// eliminate fractions then simplify both sides\nfunction normalize(eqn: IExpr) {\n    let _eqn = eqn;\n    const result = buildIfMatch([\n        { pattern: \"a/b=c/d\", template: \"ad=bc\" },\n        { pattern: \"a/b=c\", template: \"a=bc\" },\n        { pattern: \"a=c/d\", template: \"ad=c\" }], _eqn);\n    if (result) {\n        _eqn = result;\n    }\n    return simplifyExpr(_eqn);\n}\n\n// asume binex is a product\nexport function mulExprNoVar(env: IEnvironment, factor = 1): boolean {\n    const origExpr: IExpr = env.f;\n    let expr = origExpr;\n    const v = env.v as IVariable;\n    while (expr.type === ExprType.BINOP) {\n        const binex = expr as IBinop;\n        if (match(v, binex.operand2, env, true)) {\n            return false;\n        }\n        expr = binex.operand1;\n    }\n    if (!match(v, expr, env, true)) {\n        if (factor !== 1) {\n            const resBinex: IBinop = {\n                type: ExprType.BINOP, op: Operator.MUL,\n                operand1: Constants.makeInt(-1), operand2: origExpr,\n            };\n            env.nf = resBinex;\n        } else {\n            env.nf = origExpr;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction walk(expr: IExpr, pre: (e: IExpr) => boolean, post?: (e: IExpr) => void) {\n    if ((!pre) || pre(expr)) {\n        switch (expr.type) {\n            case ExprType.TUPLE: {\n                const tuple = expr as ITuple;\n                for (let i = 0, len = tuple.elements.length; i < len; i++) {\n                    walk(tuple.elements[i], pre, post);\n                }\n                break;\n            }\n            case ExprType.BINOP: {\n                walk((expr as IBinop).operand1, pre, post);\n                walk((expr as IBinop).operand2, pre, post);\n                break;\n            }\n            case ExprType.UNOP: {\n                walk((expr as IUnop).operand1, pre, post);\n                break;\n            }\n            case ExprType.CALL: {\n                // sub, super as well\n                const callExpr = expr as ICall;\n                if (callExpr.params) {\n                    for (let j = 0, clen = callExpr.params.length; j < clen; j++) {\n                        walk(callExpr.params[j], pre, post);\n                    }\n                }\n            }\n            default:\n            // console.log(`walk encountered expr type ${ExprType[expr.type]}`);\n        }\n        if (post) {\n            post(expr);\n        }\n    }\n}\n\nfunction extractTermAndDegree(term: IBinop, negate: boolean, v: IVariable) {\n    if (diagAC) {\n        const tex = exprToTexParens(term);\n        console.log(`extract term with negate ${negate}: ${tex}`);\n    }\n    let constPart: IExpr;\n    let symbolPart: IExpr;\n    let degree = 0;\n    if (negate) {\n        constPart = Constants.makeInt(-1);\n    }\n    walk(term, (e) => {\n        if (isConstant(e)) {\n            if (constPart) {\n                constPart = applyBinop({ type: ExprType.BINOP, op: Operator.MUL, operand1: constPart, operand2: e });\n            } else {\n                constPart = e;\n            }\n        } else if (e.type === ExprType.VARIABLE) {\n            if ((e as IVariable).text === v.text) {\n                degree++;\n            } else {\n                if (symbolPart) {\n                    const binex: IBinop = { type: ExprType.BINOP, op: Operator.MUL, operand1: symbolPart, operand2: e };\n                    symbolPart = simplifyExpr(binex);\n                } else {\n                    symbolPart = e;\n                }\n            }\n        } else if ((e.type === ExprType.BINOP) && ((e as IBinop).op === Operator.EXP)) {\n            const binex = e as IBinop;\n            if (binex.operand1.type === ExprType.VARIABLE) {\n                if ((binex.operand1 as IVariable).text === v.text) {\n                    degree += (binex.operand2 as IReal).value;\n                } else {\n                    if (symbolPart) {\n                        const sbinex: IBinop = {\n                            type: ExprType.BINOP, op: Operator.MUL,\n                            operand1: symbolPart, operand2: e,\n                        };\n                        symbolPart = simplifyExpr(sbinex);\n                    } else {\n                        symbolPart = e;\n                    }\n                }\n            } else {\n                console.log(\"need a variable as lhs of exponent\");\n            }\n            return false;\n        }\n        return true;\n    });\n    const outTerm: ISplitTerm = {};\n    if (symbolPart) {\n        if (constPart) {\n            const binex: IBinop = {\n                type: ExprType.BINOP, op: Operator.MUL, operand1: constPart, operand2: symbolPart,\n            };\n            outTerm.symbolPart = binex;\n        } else {\n            outTerm.symbolPart = symbolPart;\n        }\n    } else {\n        outTerm.constPart = constPart;\n    }\n\n    return {\n        splitTerm: outTerm,\n        degree,\n    };\n}\n\ninterface ISplitTerm {\n    constPart?: IExpr;\n    symbolPart?: IExpr;\n}\n\nfunction extractVarCoeff(expr: IExpr, v: IVariable, negate: boolean, degree: number) {\n    let outDegree = 0;\n    const term: ISplitTerm = {};\n    if ((expr as IVariable).text === v.text) {\n        outDegree = degree;\n        if (negate) {\n            term.constPart = Constants.makeInt(-1);\n        } else {\n            term.constPart = Constants.makeInt(1);\n        }\n    } else {\n        if (negate) {\n            const unex: IUnop = { type: ExprType.UNOP, op: Operator.SUB, operand1: expr };\n            term.symbolPart = unex;\n        } else {\n            term.symbolPart = expr;\n        }\n    }\n    return {\n        degree: outDegree,\n        splitTerm: term,\n    };\n}\n\nconst diagAC = false;\n// convert expression to polynomial coefficient array\n// assume sum of products or e1=e2 where e1 and e2 are sum of products\nfunction accumCoefficients(expr: IExpr, v: IVariable, poly: ISplitTerm[], negate: boolean) {\n    let term: ISplitTerm = {};\n    let degree = 0;\n\n    if (diagAC) {\n        const tex = exprToTexParens(expr);\n        console.log(`accum coeffs with negate ${negate}: ${tex}`);\n    }\n\n    if (isConstant(expr)) {\n        term.constPart = expr;\n        if (negate) {\n            term.constPart = Constants.negate(term.constPart as IConstant);\n        }\n    } else {\n        switch (expr.type) {\n            case ExprType.UNOP: {\n                const unex = expr as IUnop;\n                const _negate = !negate;\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return accumCoefficients(unex.operand1, v, poly, _negate);\n            }\n            case ExprType.VARIABLE: {\n                // bare v term\n                const td = extractVarCoeff(expr, v, negate, 1);\n                degree = td.degree;\n                term = td.splitTerm;\n                break;\n            }\n            case ExprType.BINOP: {\n                const binex = expr as IBinop;\n                switch (binex.op) {\n                    // expect ADD, SUB, MUL, EQ\n                    case Operator.ADD:\n                    case Operator.SUB: {\n                        accumCoefficients(binex.operand1, v, poly, negate);\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return accumCoefficients(binex.operand2, v, poly, binex.op === Operator.SUB ? !negate : negate);\n                    }\n                    case Operator.EQ: {\n                        accumCoefficients(binex.operand1, v, poly, false);\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return accumCoefficients(binex.operand2, v, poly, true);\n                    }\n                    case Operator.MUL: {\n                        const td = extractTermAndDegree(binex, negate, v);\n                        degree = td.degree;\n                        term = td.splitTerm;\n                        break;\n                    }\n                    case Operator.EXP: {\n                        if (binex.operand1.type === ExprType.VARIABLE) {\n                            if (binex.operand2.type === ExprType.INTEGER) {\n                                const td = extractVarCoeff(binex.operand1, v, negate,\n                                    (binex.operand2 as IReal).value);\n                                degree = td.degree;\n                                term = td.splitTerm;\n                            } else {\n                                console.log(\"error: non-integer exponent in accum coeffs\");\n                            }\n                        } else {\n                            console.log(\"error: complex lhs of exponent in accum coeffs\");\n                        }\n                        break;\n                    }\n                    default:\n                        console.log(`unexpected operator ${Operator[binex.op]}`);\n                }\n                break;\n            }\n            default:\n                console.log(`unexpected expr type ${ExprType[expr.type]}`);\n        }\n    }\n    if (poly[degree]) {\n        if (term.symbolPart) {\n            if (poly[degree].symbolPart) {\n                const simplex: IBinop = {\n                    type: ExprType.BINOP, op: Operator.ADD,\n                    operand1: poly[degree].symbolPart, operand2: term.symbolPart,\n                };\n                poly[degree].symbolPart = simplifyExpr(simplex);\n            } else {\n                poly[degree].symbolPart = term.symbolPart;\n            }\n        }\n        if (term.constPart) {\n            if (poly[degree].constPart) {\n                poly[degree].constPart = applyBinop({ type: ExprType.BINOP, op: Operator.ADD, operand1: poly[degree].constPart, operand2: term.constPart });\n            } else {\n                poly[degree].constPart = term.constPart;\n            }\n        }\n    } else {\n        poly[degree] = term;\n    }\n\n    return poly;\n}\n\nfunction extractCoefficients(expr: IExpr, v: IVariable) {\n    const polySplit: ISplitTerm[] = [];\n    const poly: IExpr[] = [];\n    accumCoefficients(expr, v, polySplit, false);\n    for (let i = 0, len = polySplit.length; i < len; i++) {\n        const splitTerm = polySplit[i];\n        if (splitTerm) {\n            if (splitTerm.symbolPart) {\n                poly[i] = splitTerm.symbolPart;\n                if (splitTerm.constPart) {\n                    const binex: IBinop = {\n                        type: ExprType.BINOP, op: Operator.ADD,\n                        operand1: poly[i], operand2: splitTerm.constPart,\n                    };\n                    poly[i] = binex;\n                }\n            } else {\n                poly[i] = splitTerm.constPart;\n            }\n        } else {\n            poly[i] = Constants.makeInt(0);\n        }\n    }\n    return poly;\n}\n\nexport function solve(eqn: IExpr, v: IVariable): IExpr {\n    const norm = normalize(eqn);\n    if (!isSumOfProducts(norm)) {\n        return norm;\n    }\n    const poly = extractCoefficients(norm, v);\n    if (poly[0]) {\n        if (poly[1]) {\n            if (Constants.matchConstant(Constants.makeInt(0), poly[1])) {\n                return undefined;\n            } else {\n                const op1Binex: IBinop = {\n                    type: ExprType.BINOP, op: Operator.MUL, operand1: Constants.makeInt(-1),\n                    operand2: poly[0],\n                };\n                const simplex: IBinop = {\n                    type: ExprType.BINOP, op: Operator.DIV, operand1: op1Binex,\n                    operand2: poly[1],\n                };\n                const binex: IBinop = {\n                    type: ExprType.BINOP, op: Operator.EQ, operand1: v, operand2:\n                        simplifyExpr(simplex),\n                };\n                return binex;\n            }\n        }\n    } else {\n        const binex: IBinop = { type: ExprType.BINOP, op: Operator.EQ, operand1: v, operand2: Constants.makeInt(0) };\n        return binex;\n    }\n}\n\nfunction isInt(e: IExpr, val?: number) {\n    return (e.type === ExprType.INTEGER) && ((!val) || ((e as IReal).value === val));\n}\n\nfunction subst(e: IExpr, env: IEnvironment) {\n    let evar: IExpr;\n    switch (e.type) {\n        case ExprType.VARIABLE:\n        case ExprType.PATTERNVAR: {\n            evar = env[(e as IVariable).text];\n            if (evar) {\n                return evar;\n            }\n            break;\n        }\n        case ExprType.UNOP: {\n            const unex = e as IUnop;\n            return { type: ExprType.UNOP, op: unex.op, operand1: subst(unex.operand1, env) };\n        }\n        case ExprType.BINOP: {\n            const binex = e as IBinop;\n            return {\n                type: ExprType.BINOP, op: binex.op, operand1: subst(binex.operand1, env),\n                operand2: subst(binex.operand2, env),\n            };\n        }\n        default:\n        // console.log(`unrecognized expr type ${e.type}`);\n    }\n    return e;\n}\n\nfunction buildExpr(s: string, env: IEnvironment) {\n    const template = parse(s);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return subst(template, env);\n}\n\ninterface ITransformString {\n    pattern: string;\n    template: string;\n    param?: any;\n    exec?(env: IEnvironment, arg?: any): boolean;\n}\n\ninterface IMatchInfo {\n    index?: number;\n    pat?: string;\n}\n\nconst bifMatchDiag = false;\n\nfunction buildIfMatch(pats: ITransformString[], e: IExpr, seedEnv?: () => IEnvironment, info?: IMatchInfo): IExpr {\n    let env: IEnvironment;\n    for (let i = 0, len = pats.length; i < len; i++) {\n        if (seedEnv) {\n            env = seedEnv();\n        } else {\n            env = {};\n        }\n        if (matchS(pats[i].pattern, e, env)) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            if ((!pats[i].exec) || (pats[i].exec(env, pats[i].param))) {\n                if (info) {\n                    info.index = i;\n                    info.pat = pats[i].pattern;\n                }\n                const built = buildExpr(pats[i].template, env);\n                if (bifMatchDiag) {\n                    const builtTex = exprToTex(built);\n                    const etex = exprToTex(e);\n                    console.log(`applied ${pats[i].pattern} to ${etex} yielding ${builtTex}`);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return built;\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction foldConstants(env: IEnvironment, opArg: { op: Operator; reverse?: boolean }) {\n    const ca = env.a as IConstant;\n    const cb = env.b as IConstant;\n    if (opArg.reverse) {\n        env.c = applyBinop({ type: ExprType.BINOP, op: opArg.op, operand1: cb, operand2: ca });\n    } else {\n        env.c = applyBinop({ type: ExprType.BINOP, op: opArg.op, operand1: ca, operand2: cb });\n    }\n    return true;\n}\n\nfunction combineCoeffs(env: IEnvironment, opArg: { sgn: number }) {\n    const aLeft = env.al as IConstant;\n    const aRight = env.ar as IConstant;\n    let bLeft = env.bl as IConstant;\n    let bRight = env.br as IConstant;\n\n    // aLeft * x +/- bLeft = aRight * x +/- bRight;\n    // sgn 00: -,-; 01: -,+; 10: +,-; 11: +,+\n    // (aLeft-aRight) * x  = bRight-bLeft;\n    const sgn = opArg.sgn;\n    if ((sgn & 0x1) === 0) {\n        bRight = Constants.negate(bRight);\n    }\n    if ((sgn & 0x2) === 0) {\n        bLeft = Constants.negate(bLeft);\n    }\n    env.as = applyBinop({ type: ExprType.BINOP, op: Operator.SUB, operand1: aLeft, operand2: aRight });\n    env.bs = applyBinop({ type: ExprType.BINOP, op: Operator.SUB, operand1: bRight, operand2: bLeft });\n    return true;\n}\n\nfunction negateConstantIfNegative(env: IEnvironment) {\n    const cb = env.b as IConstant;\n    if (Constants.isNegative(cb)) {\n        env.n = Constants.negate(cb);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function negateConstant(env: IEnvironment) {\n    const cb = env.b as IConstant;\n    env.n = Constants.negate(cb);\n    return true;\n}\n\nexport function divrl(env: IEnvironment) {\n    const a = env.a;\n    const b = env.b;\n\n    if (isInt(a, 0)) {\n        return false;\n    } else {\n        const q = applyBinop({ type: ExprType.BINOP, op: Operator.DIV, operand1: b, operand2: a });\n        env.q = q;\n        return true;\n    }\n}\n// const | var | -factor | var^integer\nfunction isFactor(expr: IExpr) {\n    if ((expr.type === ExprType.VARIABLE) || isConstant(expr)) {\n        return true;\n    }\n    if (expr.type === ExprType.UNOP) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return isFactor((expr as IUnop).operand1);\n    } else if (expr.type === ExprType.BINOP) {\n        const binex = expr as IBinop;\n        if (binex.op === Operator.EXP) {\n            return (binex.operand1.type === ExprType.VARIABLE) &&\n                (binex.operand2.type === ExprType.INTEGER);\n        }\n    }\n    return false;\n}\n\n// ab | -a | factor\nfunction isTerm(e: IExpr): boolean {\n    if (e.type === ExprType.BINOP) {\n        const binex = e as IBinop;\n        if (binex.op === Operator.MUL) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return isTerm(binex.operand1) && (isFactor(binex.operand2));\n        }\n    } else if (e.type === ExprType.UNOP) {\n        return isTerm((e as IUnop).operand1);\n    } else {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return isFactor(e);\n    }\n}\n\nfunction isSumOfProducts(e: IExpr): boolean {\n    switch (e.type) {\n        case ExprType.BINOP: {\n            const binex = e as IBinop;\n            if (binex.op === Operator.EQ) {\n                return isSumOfProducts(binex.operand1) && isSumOfProducts(binex.operand2);\n            }\n            if ((binex.op === Operator.ADD) || (binex.op === Operator.SUB)) {\n                return isSumOfProducts(binex.operand1) && (isSumOfProducts(binex.operand2));\n            } else if (binex.op === Operator.MUL) {\n                return isTerm(binex);\n            } else if (binex.op === Operator.EXP) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return isFactor(binex);\n            }\n        }\n        case ExprType.UNOP: {\n            return isSumOfProducts(e);\n        }\n        default:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return isFactor(e);\n    }\n}\n\nconst diagB = false;\n// find correct place to check for divide by zero\nfunction simplifyExpr(expr: IExpr): IExpr {\n    let _expr = expr;\n    let delta = true;\n    while (delta) {\n        delta = false;\n        if (diagB) {\n            const tex = exprToTexParens(_expr);\n            console.log(`simplifying ${tex}`);\n        }\n        let operand1: IExpr;\n        let operand2: IExpr;\n        switch (_expr.type) {\n            case ExprType.INTEGER:\n            case ExprType.REAL:\n            case ExprType.VARIABLE:\n                return _expr;\n            case ExprType.RATIONAL:\n                return Constants.simplifyRational(_expr as IRational);\n            case ExprType.UNOP: {\n                // currently only unary '-'\n                const unex = _expr as IUnop;\n                if (isConstant(unex.operand1)) {\n                    return Constants.negate(unex.operand1);\n                } else {\n                    operand1 = simplifyExpr(unex.operand1);\n                    if (operand1 !== unex.operand1) {\n                        delta = true;\n                        const op1Unex: IUnop = { type: ExprType.UNOP, op: unex.op, operand1 };\n                        _expr = op1Unex;\n                    }\n                }\n                break;\n            }\n            case ExprType.BINOP:\n                const binex = _expr as IBinop;\n                if (isConstant(binex.operand1)) {\n                    if (isConstant(binex.operand2)) {\n                        return applyBinop(binex);\n                    }\n                }\n                const info: IMatchInfo = { index: -1 };\n                const result = buildIfMatch([\n                    // multiplicative identity\n                    { pattern: \"1a\", template: \"a\" },\n                    { pattern: \"a1\", template: \"a\" },\n                    { pattern: \"a/1\", template: \"a\" },\n                    { pattern: \"0/a\", template: \"0\" },\n                    { pattern: \"-b:const\", template: \"?n\", exec: negateConstantIfNegative },\n                    { pattern: \"a--b\", template: \"a+b\" },\n                    { pattern: \"a-?b:const\", template: \"a+?n\", exec: negateConstantIfNegative },\n                    { pattern: \"a+?b:const\", template: \"a-?n\", exec: negateConstantIfNegative },\n                    { pattern: \"a-?b:const?c\", template: \"a+?n?c\", exec: negateConstantIfNegative },\n                    // commutative multiplication\n                    { pattern: \"a(bc)\", template: \"(ab)c\" },\n                    // distributive property\n                    { pattern: \"a(b+c)\", template: \"ab+ac\" },\n                    { pattern: \"a(b-c)\", template: \"ab-ac\" },\n                    { pattern: \"(a+b)c\", template: \"ac+bc\" },\n                    { pattern: \"(a-b)c\", template: \"ac-bc\" },\n                    // move constants to beginning of term\n                    { pattern: \"?v:var?c:const\", template: \"?c?v\" },\n                    { pattern: \"(?ca:const?e:expr)?cb:const\", template: \"(?ca?cb)?e\" },\n                    { pattern: \"?ca:const(?cb:const?e:expr)\", template: \"(?ca?cb)?e\" },\n                    { pattern: \"?e:expr?c:const\", template: \"?c?e\" },\n                    { pattern: \"?ca:const(-?cb:const)\", template: \"-1?ca?cb\" },\n                    { pattern: \"a(-b)\", template: \"-1ab\" },\n                    { pattern: \"a+-b\", template: \"a-b\" },\n                    { pattern: \"a--bc\", template: \"a+bc\" },\n                    { pattern: \"a--(bc)\", template: \"a+bc\" },\n                    { pattern: \"a+-bc\", template: \"a-bc\" },\n                    { pattern: \"a-(b-c)\", template: \"a+c-b\" },\n                    { pattern: \"-(a-b)\", template: \"b-a\" },\n                    { pattern: \"a+(b+c)\", template: \"a+b+c\" },\n                    { pattern: \"a-(b+c)\", template: \"a-b-c\" },\n                    { pattern: \"a+(b-c)\", template: \"a+b-c\" },\n                    { pattern: \"-1a\", template: \"-a\" },\n                    { pattern: \"-a+b\", template: \"b-a\" },\n                    // combine like terms\n                    { pattern: \"?a:const?x+?b:const?x\", template: \"?c?x\", exec: foldConstants, param: { op: Operator.ADD } },\n                    { pattern: \"?a:const?x-?d:const+?b:const?x\", template: \"?c?x-?d\", exec: foldConstants, param: { op: Operator.ADD } },\n                    { pattern: \"?e:expr+?a:const+?b:const\", template: \"?e+?c\", exec: foldConstants, param: { op: Operator.ADD } },\n                    { pattern: \"?e:expr+?a:const-?b:const\", template: \"?e+?c\", exec: foldConstants, param: { op: Operator.SUB } },\n                    { pattern: \"?e:expr-?a:const+?b:const\", template: \"?e+?c\", exec: foldConstants, param: { op: Operator.SUB, reverse: true } },\n                    { pattern: \"?e:expr-?a:const-?b:const\", template: \"?e-?c\", exec: foldConstants, param: { op: Operator.ADD } },\n                    { pattern: \"?a:const+?e:expr-?b:const\", template: \"?e+?c\", exec: foldConstants, param: { op: Operator.SUB } },\n                    { pattern: \"?a:const+?e:expr+?b:const\", template: \"?e+?c\", exec: foldConstants, param: { op: Operator.ADD } },\n                    // combine like terms on both sides\n                    { pattern: \"?al:const?x-?bl:const=?ar:const?x-?br:const\", template: \"?as?x=?bs\", exec: combineCoeffs, param: { sgn: 0 } },\n                    { pattern: \"?al:const?x-?bl:const=?ar:const?x+?br:const\", template: \"?as?x=?bs\", exec: combineCoeffs, param: { sgn: 1 } },\n                    { pattern: \"?al:const?x+?bl:const=?ar:const?x-?br:const\", template: \"?as?x=?bs\", exec: combineCoeffs, param: { sgn: 2 } },\n                    { pattern: \"?al:const?x+?bl:const=?ar:const?x+?br:const\", template: \"?as?x=?bs\", exec: combineCoeffs, param: { sgn: 3 } },\n                ], binex, () => (emptyEnvironment()), info);\n                if (result) {\n                    if (diagB) {\n                        console.log(`match ${info.index}: ${info.pat}`);\n                    }\n                    delta = true;\n                    _expr = result;\n                } else {\n                    if (diagB) {\n                        console.log(\"no match\");\n                    }\n                    operand1 = simplifyExpr(binex.operand1);\n                    operand2 = simplifyExpr(binex.operand2);\n                    if ((operand1 !== binex.operand1) || (operand2 !== binex.operand2)) {\n                        delta = true;\n                        const resBinex: IBinop = { type: ExprType.BINOP, op: binex.op, operand1, operand2 };\n                        _expr = resBinex;\n                    }\n                }\n                break;\n            case ExprType.CALL:\n            case ExprType.ERROR:\n                break;\n            default:\n                console.log(`simplify: unrecognized expr type ${ExprType[_expr.type]}`);\n        }\n    }\n    return _expr;\n}\n\nexport interface IExpr {\n    type: ExprType;\n    pendingParens?: string;\n    parenthesized?: boolean;\n    minChar?: number;\n    limChar?: number;\n    value?: number;\n    text?: string;\n    pvarType?: PatternVarType;\n    elements?: IExpr[];\n    op?: Operator;\n}\n\nexport interface ITuple extends IExpr {\n    elements: IExpr[];\n}\n\ninterface IUnop extends IExpr {\n    op: Operator;\n    operand1: IExpr;\n}\n\ninterface IBinop extends IUnop {\n    operand2: IExpr;\n}\n\nexport interface IConstant extends IExpr {\n    assignedVar?: IVariable;\n}\n\ninterface IReal extends IConstant {\n    value: number;\n}\n\ninterface IRational extends IConstant {\n    a: number;\n    b: number;\n}\n\ninterface ICall extends IExpr {\n    name: string;\n    notFound?: boolean;\n    sub?: IExpr;\n    exp?: IExpr;\n    prefixCmds?: IMathCommand[];\n    params: IExpr[];\n    curlies?: boolean;\n}\n\nexport interface IVariable extends IExpr {\n    text: string;\n    // subscript expression, if any\n    sub?: IExpr;\n}\n\nenum PatternVarType {\n    Const,\n    Var,\n    Expr,\n    Any,\n}\n\n// text can be more than one character\n// used in patterns that match expressions\nexport interface IPatternVar extends IVariable {\n    pvarType: PatternVarType;\n}\n\nfunction makeErrorExpr(parsedSoFar: number): IExpr {\n    return { type: ExprType.ERROR, minChar: parsedSoFar };\n}\n\nfunction getPvarType(tokStream: ITokenStream): PatternVarType {\n    const tok = tokStreamPeek(tokStream);\n    if (tok.type === MathTokenType.PatternType) {\n        tokStreamAdvance(tokStream);\n        if (tok.text === \"const\") {\n            return PatternVarType.Const;\n        } else if (tok.text === \"var\") {\n            return PatternVarType.Var;\n        } else if (tok.text === \"expr\") {\n            return PatternVarType.Expr;\n        }\n    }\n    return PatternVarType.Any;\n}\n\ninterface IParserContext {\n    prevVar?: IVariable;\n}\n\nfunction parseModExpr(tokStream: ITokenStream, ctxt: IParserContext, modTok: MathCommandToken) {\n    return parseCall(tokStream, ctxt, modTok);\n}\nfunction tryModExpr(tokStream: ITokenStream, ctxt: IParserContext,\n    callExpr: ICall, callTok: MathCommandToken) {\n    const tok = tokStreamPeek(tokStream);\n    if (tok.type === MathTokenType.Command) {\n        const cmdTok = tok as MathCommandToken;\n        if (cmdTok.isModifier) {\n            tokStreamAdvance(tokStream);\n            const modExpr = parseModExpr(tokStream, ctxt, cmdTok);\n            if (cmdTok === callTok.subCmd) {\n                callExpr.sub = modExpr;\n            } else {\n                callExpr.exp = modExpr;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction parseCall(tokStream: ITokenStream, ctxt: IParserContext,\n    callTok: MathCommandToken): ICall {\n    const callExpr: ICall = {\n        type: ExprType.CALL,\n        name: callTok.cmdInfo.key,\n        params: [],\n    };\n    if (tryModExpr(tokStream, ctxt, callExpr, callTok)) {\n        tryModExpr(tokStream, ctxt, callExpr, callTok);\n    }\n    if (callTok.cmdInfo.arity > 0) {\n        for (let i = 0; i < callTok.cmdInfo.arity; i++) {\n            callExpr.params[i] = parseExpr(tokStream, ctxt);\n            const finishTok = tokStreamGet(tokStream);\n            if ((finishTok.type !== MathTokenType.MidCommand) && (finishTok.type !== MathTokenType.EndCommand)) {\n                console.log(`unexpected token of type ${MathTokenType[finishTok.type]} ends param expr`);\n            }\n        }\n    }\n    return callExpr;\n}\n\nfunction parseTupleTail(expr: IExpr, tokStream: ITokenStream, ctxt: IParserContext): IExpr {\n    const elements = [expr];\n    let tok: MathToken;\n\n    do {\n        elements.push(parseExpr(tokStream, ctxt));\n        tok = tokStreamGet(tokStream);\n    }\n    while (tok.type === MathTokenType.COMMA);\n\n    if ((tok.type !== MathTokenType.CPAREN) && (tok.type !== MathTokenType.EOI)) {\n        return makeErrorExpr(tok.start);\n    } else {\n        const tuple: IExpr = { type: ExprType.TUPLE, elements };\n        if (tok.type === MathTokenType.EOI) {\n            tuple.pendingParens = \"(\";\n        }\n        return tuple;\n    }\n}\n\nfunction parsePrimary(tokStream: ITokenStream, ctxt: IParserContext): IExpr {\n    let tok = tokStreamGet(tokStream);\n    let expr: IExpr;\n\n    switch (tok.type) {\n        case MathTokenType.OPAREN:\n            expr = parseExpr(tokStream, ctxt);\n            tok = tokStreamGet(tokStream);\n            if (tok.type !== MathTokenType.CPAREN) {\n                if (tok.type === MathTokenType.COMMA) {\n                    return parseTupleTail(expr, tokStream, ctxt);\n                } else if (tok.type === MathTokenType.EOI) {\n                    if (expr.pendingParens) {\n                        expr.pendingParens += \"(\";\n                    } else {\n                        expr.pendingParens = \"(\";\n                    }\n                    expr.minChar = tok.start;\n                    return expr;\n                } else {\n                    return makeErrorExpr(tok.start);\n                }\n            } else {\n                expr.parenthesized = true;\n                return (expr);\n            }\n        case MathTokenType.Command: {\n            const cmdTok = tok as MathCommandToken;\n            const callExpr = parseCall(tokStream, ctxt, cmdTok);\n            if (cmdTok.isModifier && ctxt.prevVar) {\n                ctxt.prevVar.sub = callExpr;\n                ctxt.prevVar = undefined;\n            }\n            return callExpr;\n        }\n        case MathTokenType.INT:\n            return { type: ExprType.INTEGER, value: parseInt(tok.text, 10), minChar: tok.start };\n        case MathTokenType.REAL:\n            return { type: ExprType.REAL, value: parseFloat(tok.text), minChar: tok.start };\n        case MathTokenType.Variable: {\n            const symTok = tok as MathSymbolToken;\n            const vexpr: IVariable = {\n                type: ExprType.VARIABLE, text: symTok.text,\n                minChar: tok.start,\n            };\n            ctxt.prevVar = vexpr;\n            return vexpr;\n        }\n        case MathTokenType.PatternVariable: {\n            const pvarType = getPvarType(tokStream);\n            return {\n                type: ExprType.PATTERNVAR, text: tok.text,\n                pvarType, minChar: tok.start,\n            };\n        }\n        default:\n            return makeErrorExpr(tok.start);\n    }\n}\n\nfunction parseExpr(tokStream: ITokenStream, ctxt: IParserContext,\n    prevPrecedence = TokenPrecedence.NONE): IExpr {\n    let tok = tokStreamPeek(tokStream);\n    let usub = false;\n    if (tok.type === MathTokenType.SUB) {\n        // unary minus\n        tokStreamAdvance(tokStream);\n        usub = true;\n    }\n    let left = parsePrimary(tokStream, ctxt);\n    if (usub) {\n        if (isConstant(left)) {\n            left = Constants.negate(left as IConstant);\n        } else {\n            const unop: IUnop = { type: ExprType.UNOP, op: Operator.SUB, operand1: left };\n            left = unop;\n        }\n    }\n    tok = tokStreamPeek(tokStream);\n    while ((tok.type !== MathTokenType.EOI) && (tok.type !== MathTokenType.CPAREN) &&\n        (tok.type !== MathTokenType.COMMA) && (tok.type !== MathTokenType.MidCommand) &&\n        (tok.type !== MathTokenType.EndCommand)) {\n        const props = tokenProps[tok.type];\n        let rightAssoc = false;\n        let precedence: TokenPrecedence;\n        let realOpToken = true;\n        let op: Operator;\n\n        if (tok.type === MathTokenType.Command) {\n            const cmdTok = tok as MathCommandToken;\n            const cmdInfo = cmdTok.cmdInfo;\n            if (cmdInfo && cmdInfo.infix) {\n                op = cmdInfo.op;\n                precedence = operatorToPrecedence[op];\n            } else {\n                // treat as impending multiply\n                precedence = TokenPrecedence.MUL;\n                realOpToken = false;\n                op = Operator.MUL;\n            }\n        } else if (props.flags & TokenLexFlags.Binop) {\n            precedence = props.precedence;\n            op = props.op;\n            rightAssoc = props.rightAssoc;\n        } else if (props.flags & TokenLexFlags.PrimaryFirstSet) {\n            precedence = TokenPrecedence.MUL;\n            realOpToken = false;\n            op = Operator.MUL;\n        }\n        if ((prevPrecedence < precedence) || ((prevPrecedence === precedence) && rightAssoc)) {\n            // previous op has weaker precedence\n            if (realOpToken) {\n                tokStreamAdvance(tokStream);\n            }\n            const right = parseExpr(tokStream, ctxt, precedence);\n            const binex: IBinop = { type: ExprType.BINOP, op, operand1: left, operand2: right };\n            left = binex;\n        } else {\n            return left;\n        }\n        tok = tokStreamPeek(tokStream);\n    }\n    return left;\n}\n\nfunction parseEqn(tokStream: ITokenStream): IExpr {\n    let ctxt: IParserContext = {};\n    const left = parseExpr(tokStream, ctxt, TokenPrecedence.REL);\n    const tok = tokStreamGet(tokStream);\n    if (tok.type === MathTokenType.Equals) {\n        ctxt = {};\n        const right = parseExpr(tokStream, ctxt, TokenPrecedence.IMPLIES);\n        const binex: IBinop = {\n            type: ExprType.BINOP, op: Operator.EQ, operand1: left,\n            operand2: right,\n        };\n        return binex;\n    }\n}\n\nexport function testEqn(s: string, norm = false, vsolve?: IVariable) {\n    console.log(`trying ${s} ...`);\n    const tokStream = tokStreamCreate(s, lexMath(s));\n    let e = parseEqn(tokStream);\n    if (e) {\n        console.log(`which is ${exprToTexParens(e)}`);\n        if (norm) {\n            e = normalize(e);\n            if (vsolve) {\n                e = solve(e, vsolve);\n            }\n        }\n        if (e) {\n            const tex = exprToTex(e, false);\n            console.log(tex);\n        } else if (vsolve) {\n            console.log(`no solution for ${vsolve.text}`);\n        }\n    } else {\n        if (vsolve) {\n            console.log(`no solution for ${vsolve.text}`);\n        }\n    }\n}\nfunction getLine(s: string, tokenIndex: number, tokens: MathToken[]) {\n    let start = 0;\n    let end = s.length;\n    for (let i = tokenIndex; i < tokens.length; i++) {\n        if (tokens[i].type === MathTokenType.Newline) {\n            end = tokens[i].start;\n            break;\n        }\n    }\n    for (let i = tokenIndex - 1; i >= 0; i--) {\n        if (tokens[i].type === MathTokenType.Newline) {\n            start = tokens[i].start + 1;\n            break;\n        }\n    }\n    const line = s.substring(start, end);\n    return line;\n}\nexport function testExprLine(s: string, tokenIndex: number, tokens: MathToken[]) {\n    const xvar: IVariable = { text: \"x\", type: ExprType.VARIABLE };\n    const line = getLine(s, tokenIndex, tokens);\n    testEqn(line, true, xvar);\n}\n\nfunction equivalent(e: IExpr, soln: IExpr, v: IVariable) {\n    let _e = e;\n    if ((_e.type !== ExprType.BINOP) || ((_e as IBinop).op !== Operator.EQ)) {\n        return false;\n    }\n    _e = simplifyExpr(_e);\n    _e = solve(_e, v);\n    const solnEqn = soln as IBinop;\n    const eqn = _e as IBinop;\n    if (eqn &&\n        match(solnEqn.operand1, eqn.operand1, {}, true) &&\n        match(solnEqn.operand2, eqn.operand2, {}, true)) {\n        return true;\n    } else if (eqn &&\n        match(solnEqn.operand1, eqn.operand2, {}, true) &&\n        match(solnEqn.operand2, eqn.operand1, {}, true)) {\n        return true;\n    }\n    return false;\n}\n\nexport function matchSolution(line: string, varName: string, varExpr: string) {\n    const e = parse(line);\n    const v: IVariable = { text: varName, type: ExprType.VARIABLE };\n    const soln = parse(varExpr);\n    return equivalent(e, soln, v);\n}\n\nexport function testExpr(s: string) {\n    console.log(`trying ${s} ...`);\n    const tokStream = tokStreamCreate(s, lexMath(s));\n    const ctxt: IParserContext = {};\n    const e = parseExpr(tokStream, ctxt);\n    const tex = exprToTex(e);\n    console.log(tex);\n}\n\nexport function testNorm() {\n    testEqn(\"3/(2a+1)=4/(a-1)\", true);\n    testEqn(\"(5--1)/(2a+1-3)=(1--2)/(a-1)\", true);\n    testEqn(\"(-5--1)/(2a+1--3)=(1--2)/(a-1)\", true);\n    testEqn(\"5--1=0\", true);\n    testEqn(\"(a-b)/(c-d)=(x-y)/(w-z)\", true);\n    testEqn(\"3(x+1)=0\", true);\n    testEqn(\"3(x+y)=0\", true);\n    testEqn(\"(a+b)(x+1)=0\", true);\n    testEqn(\"3(x-1)=0\", true);\n    testEqn(\"3(x-y)=0\", true);\n    testEqn(\"(a+b)(x-1)=0\", true);\n    testEqn(\"(5+2)(x+1)=0\", true);\n    testEqn(\"(5+2)(x-1)=0\", true);\n    testEqn(\"(a-b)(c-d)=0\", true);\n}\n\nexport function testSolve() {\n    const a = { type: ExprType.VARIABLE, text: \"a\" };\n    const x = { type: ExprType.VARIABLE, text: \"x\" };\n    // testEqn(\"x+x+5x-3=2x-2\", true, x);\n    // testEqn(\"x-3+5x+x=2x-1-1\",true, x);\n    testEqn(\"x-d-3+c-yx+zx=2x-2\", true, x);\n    testEqn(\"6-6a=4a+8\", true, a);\n    testEqn(\"4a+16=14a-14\", true, a);\n    testEqn(\"4a-16=14a-14\", true, a);\n    testEqn(\"2a+1=2a-1\", true, a);\n    testEqn(\"3/(2a+1)=4/(a-1)\", true, a);\n    testEqn(\"(5--1)/(2a+1-3)=(1--2)/(a-1)\", true, a);\n    testEqn(\"(-5--1)/(2a+1-3)=(1--2)/(a-1)\", true, a);\n    testEqn(\"3xy-5=0\", true, x);\n    testEqn(\"x3-5=0\", true, x);\n    testEqn(\"3yx-5=0\", true, x);\n    testEqn(\"3yx=0\", true, x);\n    testEqn(\"x+x+5x=2x-2\", true, x);\n    testEqn(\"x+x+5x-3=2x-2\", true, x);\n}\n\nfunction testLCDPair(a1: number, b1: number, a2: number, b2: number) {\n    const rr = Constants.lcd({ type: ExprType.RATIONAL, a: a1, b: b1 },\n        { type: ExprType.RATIONAL, a: a2, b: b2 });\n    let tex = exprToTex(rr.r1);\n    console.log(tex);\n    tex = exprToTex(rr.r2);\n    console.log(tex);\n}\n\nexport function testLCD() {\n    testLCDPair(2, 3, 5, 12);\n    testLCDPair(1, 5, 0, 1);\n}\n\nexport function testMatch() {\n    let env: IEnvironment = {};\n    let eout: IExpr;\n    let tex: string;\n\n    let e = parse(\"(6-6a)+(-4a)\");\n    if (!matchS(\"a+-bc\", e, env)) {\n        console.log(\"hmm...\");\n    }\n\n    e = parse(\"2y-(3x-7)\");\n    env = {};\n\n    if (matchS(\"a-(b-c)\", e, env)) {\n        eout = buildExpr(\"a+c-b\", env);\n        tex = exprToTex(eout);\n        console.log(tex);\n    } else {\n        console.log(\"hmmm...\");\n    }\n    e = parse(\"x4\");\n    env = {};\n    if (matchS(\"?v:var?c:const\", e, env)) {\n        eout = buildExpr(\"?c?v\", env);\n        tex = exprToTex(eout);\n        console.log(tex);\n    } else {\n        console.log(\"(1) hmmm...\");\n    }\n    e = parse(\"ac-ad-(bc-bd)\");\n    env = {};\n    if (matchS(\"a-(b-c)\", e, env)) {\n        eout = buildExpr(\"a+c-b\", env);\n        tex = exprToTex(eout);\n        console.log(tex);\n    } else {\n        console.log(\"(2) hmmm...\");\n    }\n\n    // e = parse(\"1x\");\n    e = parse(\"(3)(1)\");\n    env = {};\n    const result = buildIfMatch([\n        { pattern: \"1a\", template: \"a\" },\n        { pattern: \"a1\", template: \"a\" }], e);\n\n    if (result) {\n        tex = exprToTex(result);\n        console.log(tex);\n    } else {\n        console.log(\"(3) hmmm...\");\n    }\n}\n"]}