{"version":3,"file":"serviceAudience.js","sourceRoot":"","sources":["../src/serviceAudience.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { IAudience } from \"@fluidframework/container-definitions\";\nimport { Container } from \"@fluidframework/container-loader\";\nimport { IClient } from \"@fluidframework/protocol-definitions\";\nimport { IServiceAudience, IServiceAudienceEvents, IMember } from \"./types\";\n\n// Base class for providing audience information for sessions interacting with FluidContainer\n// This can be extended by different service-specific client packages to additional parameters to\n// the user and client details returned in IMember\nexport abstract class ServiceAudience<M extends IMember = IMember>\n  extends TypedEventEmitter<IServiceAudienceEvents<M>>\n  implements IServiceAudience<M> {\n  protected readonly audience: IAudience;\n\n  /**\n   * Retain the most recent member list.  This is so we have more information about a member\n   * leaving the audience in the removeMember event.  It allows us to match the behavior of the\n   * addMember event where it only fires on a change to the members this class exposes (and would\n   * actually produce a change in what getMembers returns).  It also allows us to provide the\n   * client details in the event which makes it easier to find that client connection in a map\n   * keyed on the userId and not clientId.\n   * This map will always be up-to-date in a removeMember event because it is set once at\n   * construction and in every addMember event.\n   * It is mapped clientId to M to be better work with what the IAudience event provides\n   */\n  protected lastMembers: Map<string, M> = new Map();\n\n  constructor(\n      protected readonly container: Container,\n  ) {\n    super();\n    this.audience = container.audience;\n\n    // getMembers will assign lastMembers so the removeMember event has what it needs\n    // in case it would fire before getMembers otherwise gets called the first time\n    this.getMembers();\n\n    this.audience.on(\"addMember\", (clientId: string, details: IClient) => {\n      if (this.shouldIncludeAsMember(details)) {\n        const member = this.getMember(clientId);\n        this.emit(\"memberAdded\", clientId, member);\n        this.emit(\"membersChanged\");\n      }\n    });\n\n    this.audience.on(\"removeMember\", (clientId: string) => {\n      if (this.lastMembers.has(clientId)) {\n        this.emit(\"memberRemoved\", clientId, this.lastMembers.get(clientId));\n        this.emit(\"membersChanged\");\n      }\n    });\n  }\n\n  protected abstract createServiceMember(audienceMember: IClient): M;\n\n  /**\n   * {@inheritDoc IServiceAudience.getMembers}\n   */\n  public getMembers(): Map<string, M> {\n    const users = new Map<string, M>();\n    const clientMemberMap = new Map<string, M>();\n    // Iterate through the members and get the user specifics.\n    this.audience.getMembers().forEach((member: IClient, clientId: string) => {\n      if (this.shouldIncludeAsMember(member)) {\n        const userId = member.user.id;\n        // Ensure we're tracking the user\n        let user = users.get(userId);\n        if (user === undefined) {\n          user = this.createServiceMember(member);\n          users.set(userId, user);\n        }\n\n        // Add this connection to their collection\n        user.connections.push({ id: clientId, mode: member.mode });\n        clientMemberMap.set(clientId, user);\n      }\n    });\n    this.lastMembers = clientMemberMap;\n    return users;\n  }\n\n  /**\n   * {@inheritDoc IServiceAudience.getMyself}\n   */\n  public getMyself(): M | undefined {\n    const clientId = this.container.clientId;\n    if (clientId === undefined) {\n      return undefined;\n    }\n    return this.getMember(clientId);\n  }\n\n  private getMember(clientId: string): M | undefined {\n    // Fetch the user ID assoicated with this client ID from the runtime\n    const internalAudienceMember = this.audience.getMember(clientId);\n    if (internalAudienceMember === undefined) {\n      return undefined;\n    }\n    // Return the member object with any other clients associated for this user\n    const allMembers = this.getMembers();\n    const member = allMembers.get(internalAudienceMember?.user.id);\n    if (member === undefined) {\n      throw Error(`Attempted to fetch client ${clientId} that is not part of the current member list`);\n    }\n    return member;\n  }\n\n  protected shouldIncludeAsMember(member: IClient): boolean {\n    // Include only human members\n    return member.details.capabilities.interactive;\n  }\n}\n"]}