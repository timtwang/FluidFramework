{"version":3,"file":"signalManager.js","sourceRoot":"","sources":["../src/signalManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { EventEmitter } from \"events\";\nimport { IErrorEvent } from \"@fluidframework/common-definitions\";\nimport { TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { Jsonable } from \"@fluidframework/datastore-definitions\";\nimport { IInboundSignalMessage } from \"@fluidframework/runtime-definitions\";\n\n// TODO:\n// add way to mark with current sequence number for ordering signals relative to ops\n// throttling and batching\n\nexport type SignalListener = (clientId: string, local: boolean, payload: Jsonable) => void;\n\n/**\n * ISignalManager defines an interface for working with signals that is similar to the more common\n * eventing patterns of EventEmitter.  In addition to sending and responding to signals, it\n * provides explicit methods around signal requests to other connected clients.\n */\nexport interface ISignalManager {\n    /**\n     * Adds a listener for the specified signal.  It behaves in the same way as EventEmitter's `on`\n     * method regarding multiple registrations, callback order, etc.\n     * @param signalName - The name of the signal\n     * @param listener - The callback signal handler to add\n     * @returns This ISignalManager\n     */\n    onSignal(signalName: string, listener: SignalListener): ISignalManager;\n     /**\n     * Remove a listener for the specified signal.  It behaves in the same way as EventEmitter's\n     * `off` method regarding multiple registrations, removal order, etc.\n     * @param signalName - The name of the signal\n     * @param listener - The callback signal handler to remove\n     * @returns This ISignalManager\n     */\n    offSignal(signalName: string, listener: SignalListener | ((message: any) => void)): ISignalManager;\n    /**\n     * Send a signal with payload to its connected listeners.\n     * @param signalName - The name of the signal\n     * @param payload - The data to send with the signal\n     */\n    submitSignal(signalName: string, payload?: Jsonable);\n\n    /**\n     * Adds a listener for a broadcast request.  The listener is called when a client calls\n     * `requestBroadcast` for that signal.  It behaves in the same way as EventEmitter's `on`\n     * method regarding multiple registrations, callback order, etc.\n     * @param signalName - The signal for which broadcast is requested\n     * @param listener - The callback for the broadcast request to add\n     * @returns This ISignalManager\n     */\n    onBroadcastRequested(signalName: string, listener: SignalListener): ISignalManager;\n    /**\n     * Remove a listener for a broadcast request.  It behaves in the same way as EventEmitter's\n     * `off` method regarding multiple registrations, removal order, etc.\n     * @param signalName  - The signal for which broadcast is requested\n     * @param listener - The callback for the broadcast request to remove\n     * @returns This ISignalManager\n     */\n    offBroadcastRequested(signalName: string, listener: SignalListener): ISignalManager;\n    /**\n     * Request broadcast of a signal from other connected clients.  Other clients must have\n     * registered to respond to broadcast requests using the `onBroadcastRequested` method.\n     * @param signalName - The signal for which broadcast is requested\n     * @param payload - A payload to send with the broadcast request\n     */\n    requestBroadcast(signalName: string, payload?: Jsonable);\n}\n\n/**\n * Duck type of something that provides the expected signalling functionality:\n * A way to verify we can signal, a way to send a signal, and a way to listen for incoming signals\n */\nexport interface ISignaler {\n    connected: boolean;\n    on(event: \"signal\", listener: (message: IInboundSignalMessage, local: boolean) => void);\n    submitSignal(type: string, content: any): void;\n}\n\n/**\n * Note: currently experimental and under development\n *\n * Helper class to assist common scenarios around working with signals.  SignalManager wraps an\n * object with signaling functionality (e.g. ContainerRuntime or FluidDataStoreRuntime) and can\n * then be used in place of the original signaler.  It uses a separate internal EventEmitter to\n * manage callbacks, and thus will reflect that behavior with regards to callback registration and\n * deregistration.\n */\nexport class SignalManager extends TypedEventEmitter<IErrorEvent> implements ISignalManager {\n    private readonly emitter  = new EventEmitter();\n\n    private readonly managerId: string | undefined;\n\n    constructor(\n        /**\n         * Object to wrap that can submit and listen to signals\n         */\n        private readonly signaler: ISignaler,\n        /**\n         * Optional id to assign to this manager that will be attached to\n         * signal names.  Useful to avoid collisions if there are multiple\n         * signal users at the Container level\n         */\n        managerId?: string,\n    ) {\n        super();\n        this.managerId = managerId ? `#${managerId}` : undefined;\n        this.signaler.on(\"signal\", (message: IInboundSignalMessage, local: boolean) => {\n            const clientId = message.clientId;\n            // Only call listeners when the runtime is connected and if the signal has an\n            // identifiable sender clientId.  The listener is responsible for deciding how\n            // it wants to handle local/remote signals\n            // eslint-disable-next-line no-null/no-null\n            if (this.signaler.connected && clientId !== null) {\n                this.emitter.emit(message.type, clientId, local, message.content);\n            }\n        });\n    }\n\n    private getManagerSignalName(signalName: string): string {\n        return this.managerId ? `${signalName}${this.managerId}` : signalName;\n    }\n\n    private getBroadcastSignalName(signalName: string): string {\n        return `${signalName}#req`;\n    }\n\n    // ISignalManager methods\n\n    public onSignal(\n        signalName: string,\n        listener: SignalListener,\n    ): ISignalManager {\n        const managerSignalName = this.getManagerSignalName(signalName);\n        this.emitter.on(managerSignalName, listener);\n        return this;\n    }\n\n    public offSignal(\n        signalName: string,\n        listener: SignalListener,\n    ): ISignalManager {\n        const managerSignalName = this.getManagerSignalName(signalName);\n        this.emitter.off(managerSignalName, listener);\n        return this;\n    }\n\n    public submitSignal(\n        signalName: string,\n        payload?: Jsonable,\n    ) {\n        const managerSignalName = this.getManagerSignalName(signalName);\n        if (this.signaler.connected) {\n            this.signaler.submitSignal(managerSignalName, payload);\n        }\n    }\n\n    public onBroadcastRequested(\n        signalName: string,\n        listener: SignalListener,\n    ) {\n        const broadcastSignalName = this.getBroadcastSignalName(signalName);\n        return this.onSignal(broadcastSignalName, listener);\n    }\n\n    public offBroadcastRequested(\n        signalName: string,\n        listener: SignalListener,\n    ) {\n        const broadcastSignalName = this.getBroadcastSignalName(signalName);\n        return this.offSignal(broadcastSignalName, listener);\n    }\n\n    public requestBroadcast(\n        signalName: string,\n        payload?: Jsonable,\n    ) {\n        const broadcastSignalName = this.getBroadcastSignalName(signalName);\n        this.submitSignal(broadcastSignalName, payload);\n    }\n}\n"]}