{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAWH;;GAEG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,GAAQ,EAA+B,EAAE;IACvE,OAAO,CAAA,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,OAAO,MAAK,SAAS,CAAC;AACtC,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,GAAQ,EAAiC,EAAE;IAC3E,OAAO,CAAA,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,UAAU,MAAK,SAAS,CAAC;AACzC,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,iCAAiC,GAAG,CAAC,MAAuB,EACb,EAAE;IAC1D,MAAM,eAAe,GAA0C,IAAI,GAAG,EAAE,CAAC;IACzE,MAAM,aAAa,GAAyB,IAAI,GAAG,EAAE,CAAC;IAEtD,MAAM,YAAY,GAAG,CAAC,GAA6B,EAAE,EAAE;QACnD,IAAI,mBAAmB,CAAC,GAAG,CAAC,EAAE;YAC1B,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC;SACvC;aAAM,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE;YAC/B,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SACzE;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;SACtE;IACL,CAAC,CAAC;IAEF,gDAAgD;IAChD,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;QACjD,YAAY,CAAC,GAAG,CAAC,CAAC;IACtB,CAAC,CAAC,CAAC;IAEH,yDAAyD;IACzD,IAAI,MAAM,CAAC,kBAAkB,EAAE;QAC3B,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,kBAAkB,EAAE;YACzC,YAAY,CAAC,GAAG,CAAC,CAAC;SACrB;KACJ;IAED,IAAI,eAAe,CAAC,IAAI,KAAK,CAAC,IAAI,aAAa,CAAC,IAAI,KAAK,CAAC,EAAE;QACxD,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;KAC5E;IAED,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;AACpE,CAAC,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IChannelFactory } from \"@fluidframework/datastore-definitions\";\nimport { NamedFluidDataStoreRegistryEntry } from \"@fluidframework/runtime-definitions\";\nimport {\n    ContainerSchema,\n    DataObjectClass,\n    LoadableObjectClass,\n    SharedObjectClass,\n} from \"./types\";\n\n/**\n * Runtime check to determine if a class is a DataObject type\n */\nexport const isDataObjectClass = (obj: any): obj is DataObjectClass<any> => {\n    return obj?.factory !== undefined;\n};\n\n/**\n * Runtime check to determine if a class is a SharedObject type\n */\nexport const isSharedObjectClass = (obj: any): obj is SharedObjectClass<any> => {\n    return obj?.getFactory !== undefined;\n};\n\n/**\n * The ContainerSchema consists of initialObjects and dynamicObjectTypes. These types can be\n * of both SharedObject or DataObject. This function seperates the two and returns a registery\n * of DataObject types and an array of SharedObjects.\n */\nexport const parseDataObjectsFromSharedObjects = (schema: ContainerSchema):\n    [NamedFluidDataStoreRegistryEntry[], IChannelFactory[]] => {\n    const registryEntries: Set<NamedFluidDataStoreRegistryEntry> = new Set();\n    const sharedObjects: Set<IChannelFactory> = new Set();\n\n    const tryAddObject = (obj: LoadableObjectClass<any>) => {\n        if (isSharedObjectClass(obj)) {\n            sharedObjects.add(obj.getFactory());\n        } else if (isDataObjectClass(obj)) {\n            registryEntries.add([obj.factory.type, Promise.resolve(obj.factory)]);\n        } else {\n            throw new Error(`Entry is neither a DataObject or a SharedObject`);\n        }\n    };\n\n    // Add the object types that will be initialized\n    Object.values(schema.initialObjects).forEach((obj) => {\n        tryAddObject(obj);\n    });\n\n    // If there are dynamic object types we will add them now\n    if (schema.dynamicObjectTypes) {\n        for (const obj of schema.dynamicObjectTypes) {\n            tryAddObject(obj);\n        }\n    }\n\n    if (registryEntries.size === 0 && sharedObjects.size === 0) {\n        throw new Error(\"Container cannot be initialized without any DataTypes\");\n    }\n\n    return [Array.from(registryEntries), Array.from(sharedObjects)];\n};\n"]}