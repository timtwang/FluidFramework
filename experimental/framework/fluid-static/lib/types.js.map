{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IEvent, IEventProvider } from \"@fluidframework/common-definitions\";\nimport { IFluidLoadable } from \"@fluidframework/core-interfaces\";\nimport { IChannelFactory } from \"@fluidframework/datastore-definitions\";\nimport { IFluidDataStoreFactory } from \"@fluidframework/runtime-definitions\";\n\nexport type LoadableObjectRecord = Record<string, IFluidLoadable>;\n\nexport type LoadableObjectClassRecord = Record<string, LoadableObjectClass<any>>;\n\n/**\n * A LoadableObjectClass is an class object of DataObject or SharedObject\n */\nexport type LoadableObjectClass<T extends IFluidLoadable> = DataObjectClass<T> | SharedObjectClass<T>;\n\n/**\n * A DataObjectClass is a class that has a factory that can create a DataObject and a\n * contructor that will return the type of the DataObject.\n */\nexport type DataObjectClass<T extends IFluidLoadable>\n    = { readonly factory: IFluidDataStoreFactory }  & LoadableObjectCtor<T>;\n\n/**\n * A SharedObjectClass is a class that has a factory that can create a DDS (SharedObject) and a\n * contructor that will return the type of the DataObject.\n */\nexport type SharedObjectClass<T extends IFluidLoadable>\n    = { readonly getFactory: () => IChannelFactory } & LoadableObjectCtor<T>;\n\n/**\n * An object with a constructor that will return an `IFluidLoadable`.\n */\nexport type LoadableObjectCtor<T extends IFluidLoadable> = new(...args: any[]) => T;\n\nexport interface ContainerSchema {\n    /**\n     * Name of the container being defined.\n     *\n     * This property is not currently used by Fluid but instead provides the developer a centralized\n     * location to name their container. It is useful in multi-container scenarios.\n     */\n    name: string;\n\n    /**\n     * initialObjects defines loadable objects that will be created when the Container\n     * is first created. It uses the key as the id and the value as the loadable object to create.\n     *\n     * In the example below two objects will be created when the Container is first\n     * created. One with id \"map1\" that will return a `SharedMap` and the other with\n     * id \"pair1\" that will return a `KeyValueDataObject`.\n     *\n     * ```\n     * {\n     *   map1: SharedMap,\n     *   pair1: KeyValueDataObject,\n     * }\n     * ```\n     */\n    initialObjects: LoadableObjectClassRecord;\n\n    /**\n     * Dynamic objects are Loadable objects that can be created after the initial Container creation.\n     *\n     * Types defined in `initialObjects` will always be available and are not required to be provided here.\n     *\n     * For best practice it's recommended to define all the dynamic types you create even if they are\n     * included via initialObjects.\n     */\n    dynamicObjectTypes?: LoadableObjectClass<any>[];\n}\n\n/**\n * Events that trigger when the roster of members in the Fluid session change.\n * Only changes that would be reflected in the returned map of IServiceAudience's getMembers method\n * will emit events.\n */\nexport interface IServiceAudienceEvents<M extends IMember> extends IEvent {\n    (event: \"membersChanged\", listener: () => void): void;\n    (event: \"memberAdded\" | \"memberRemoved\", listener: (clientId: string, member: M) => void): void;\n}\n\n/**\n * Base interface to be implemented to fetch each service's audience. The generic M allows consumers to further\n * extend the client object with service-specific details about the connecting client, such as device information,\n * environme\n */\nexport interface IServiceAudience<M extends IMember> extends IEventProvider<IServiceAudienceEvents<M>> {\n    /**\n     * Returns an map of all users currently in the Fluid session where key is the userId and the value is the\n     * member object.  The implementation may choose to exclude certain connections from the returned map.\n     * E.g. ServiceAudience excludes non-interactive connections to represent only the roster of live users.\n     */\n    getMembers(): Map<string, M>;\n\n    /**\n     * Returns the current active user on this client once they are connected. Otherwise, returns undefined.\n     */\n    getMyself(): M | undefined;\n}\n\n/**\n * Base interface for information for each connection made to the Fluid session, which will be\n * different even if it is by the same user, i.e. the connection's id will be uniquely generated for each time the user\n * connects This interface can be extended to provide additional information specific to each service.\n */\nexport interface IConnection {\n    id: string;\n    mode: \"write\" | \"read\";\n}\n\n/**\n * Base interface to be implemented to fetch each service's member. The user ID is unique for each individual\n * user that is connecting to the session. However, one user may have multiple connections from different tabs,\n * devices, etc. and the information for each is provided within the connections array. This interface can be\n * extended by each service to provide additional service-specific user metadata.\n */\nexport interface IMember {\n    userId: string;\n    connections: IConnection[];\n}\n"]}